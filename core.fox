#line 2 "/web/fox/core.fox"
//#define NDEBUG
#include "fox.h"

#define MAXMEM 10*1024*1024
#define MIN_CHAIN 1

struct gcdata _gcdata={0};
map* _globals=NULL;
size_t _clockstart=0;

int _printed=0;
int _total_time=0;

char* skip=NULL;

int rand();
void* px(void* str,int newline=1);
void xexit(int val=0);
void* fox_error(char* msg,int dump=0);

int mem_total(){
	ret=0
	pg.each_mem(mem_i) => ret+=pg->blocks*pg->block_size
	return ret
}
int mem_free(){
	ret=0
	pg.each_mem(mem_i) => ret+=pg->free*pg->block_size
	return ret
}
void fox_signal_handler(int sig) => fox_stack_dump()
void stack_dump_direct(){
	void *array[400]
	size_t size=array.backtrace(400)
	array.backtrace_symbols_fd(size,STDERR_FILENO)
	xexit(-1)
}
char* stack_str(){
	void *array[400]
	size_t size=array.backtrace(400)
	char** lines=array.backtrace_symbols(size)
	ret=''
	for i=0;i<size;i++ => ret.=lines[i].."\n"
	return ret
}
void fox_stack_dump() => fox_error("Crashed!\n",1)
char* sub_str(char* src,int from,int len=0){
	int slen=src.str_len()
	if !slen => return ""
	if from < 0 => from+=slen
	if len<=0 => len+=slen-from
	if len<=0 => return NULL
	if from>=slen => return NULL
	if from+len>=slen => return (src+from).str_dup()
	char* ret=new_str(len)
	ret.memcpy(src+from,len)
	assert(!ret[len])
	return ret
}
char* print(char* str,FILE* fp=stdout){
	_printed=1
	int ret=fwrite(str.null_str(),1,str.null_str().str_len(),fp)
	assert(ret==str.null_str().str_len())
	return str
}
char* str_times(char* str,int times){
	if times<=0 => return NULL
	char* ret=new_str(str.strlen()*times)
	while(times--) ret.=str
	return ret
}
char* xstr(char* ret, char* ...){
	ret=ret.str_dup()
	va_list args
	args.va_start(ret)
	while 1
		char* str=args.va_arg(char*)
		if str==End => break
		ret.=str
	args.va_end()
	return ret
}
char* xcat(char* ret, char* ...){
	va_list args
	args.va_start(ret)
	while 1
		char* str=args.va_arg(char*)
		if str==End => break
		ret=ret.cat(str.to_str())
	args.va_end()
	return ret
}
char* cat(char* str1,char* str2){
	assert((!str1 || str1.is_str()) && (!str2 || str2.is_str()))
	if !str2 => return str1
	if !str1 => return str2.str_dup()
	str1=str1.fox_realloc(str1.str_len()+str2.str_len()+1,str1.ptr_type())
	(str1+str1.str_len()).memcpy(str2,str2.str_len())
	if str1.ptr_type()==Blob => *(size_t*)(str1-8)+=str2.str_len()
	assert(!str1[str1.str_len()])
	return str1
}
char* vec_json(map* mp,int indent=0){
	if !mp => return "[]"
	if !mp.is_vec() => return mp.json(indent)
	char* ret=NULL
	ret.="["
	mp.each v,,i
		if !v => ret.=:null
		else if v.is_str() => ret.=v.str_quote()
		else if v.is_num() => ret.=v
		else if v.is_map() => ret.=v.is_map().vec_json(indent ? indent+1 : 0)
		ret.=", "
		
	if ret.str_len()==1 => ret.="]"
	else
		ret[ret.str_len()-2]=']'
		ret[ret.str_len()-1]='\0'
	return ret
}
char* json(map* mp,int indent=0){
	if !mp.map_len() => return "{}"
	if mp.is_vec() => return mp.vec_json(indent)
	if !mp.is_map() => return NULL
	char* ret=NULL
	ret.="{"
	mp.each v,k,i
		if indent => ret=ret.xcat("\n","\t".str_times(indent-1))
		if k.is_i() => ret.=(k.is_int()-1).int_str()
		else if k.is_f() => ret.=k
		else ret.=k.is_str().str_quote()
		ret.=":"
		if v.is_str() => ret.=v.is_str().str_quote()
		else if !v => ret.=:null
		else if v.is_map() => ret.=v.is_map().json(indent ? indent+1 : 0)
		else ret.=v
		if i<mp->len-1 => ret.=", "
		
	if ret.str_len()>1 && indent => ret=ret.xcat("\n","\t".str_times(indent-2))
	ret.="}"
	return ret
}
char* to_str(void* v,char* null="",int human=0){
	if !v => return NULL
	else if v.is_str() => return v
	else if v.is_i() => return v.is_int().int_str()
	else if v.is_f() => return v.is_double().double_str()
	else if v.is_map() => return v.json(human)
	else return ""
}
size_t blob_size(char* in){
	if !in => return 0
	char* head=in.ptr_head()
	return *(size_t*)head-(in-head-8)
}
char* new_blob(int size){
	char* ret=fox_alloc(size+8+1,Blob)
	*(size_t*)ret=size
	ret+=sizeof(size_t)
	assert(ret.str_len()==size)
	assert(!ret[size])
	return ret
}
char* str_dup_len(char* str, int len){
	if !str => return NULL
	if str.is_blob()
		return new_blob(len).memcpy(str,len)
	char* ret=new_str(len)
	ret.memcpy(str,len)
	ret[len]='\0'
	return ret
}
char* str_dup(char* str) => return str.str_dup_len(str.str_len())
char* str_quote(char* head){
	if !head => return "\"\""
	len=head.str_len()
	extra=0
	char c
	char* str=head
	char* quotable="\\\"\n\r\t"
	char* quoteto="\\\"nrt"
	while((c=*str++)) if quotable.strchr(c) => extra++
	assert(extra<=len)
	char* ret=new_str(head.str_len()+extra+2)
	ret[0]='"'
	str=head
	i=1
	char* fox_at
	while((c=*str++))
		if !(fox_at=quotable.strchr(c)) => ret[i++]=c; continue
		ret[i++]='\\'
		ret[i++]=quoteto[fox_at-quotable]
		assert(i<len+extra+2)
	
	ret[i]='"'
	assert(!ret[i+1])
	return ret
}
char* double_str(double val){
	char ret[21]={0}
	ret.sprintf("%.14g",val)
	return ret.str_dup()
}
char* int_str(long long value){
	neg=0
	if value<0
		value*=-1
		neg=1
	char string[21]={0}
	int string_l=(value == 0) ? 1 : (int)value.log10() + 1 + neg
	residual=value
	it=0
	for it=string_l-1;it>=0;it--
		int digit
		digit=residual % 10
		residual=residual / 10
		string[it]='0' + digit
	
	string[string_l]='\0'
	if neg => string[0]='-'
	return string.str_dup()
}
int str_eq(char* str,char* str1) => return !str||!str1||!str.is_str() ? 0 : str.strcmp(str1)==0
size_t str_hash(unsigned char *str){
	int c
	size_t ret = 5381
	while((c=*str++)) ret=((ret<<5)+ret)+c
	return ret ? ret : 0x08db1118c533c700; //don't return 0
}
map* xvec(void* v1=End, void* ...){
	mp=[]
	if v1==End => return mp
	mp[]=v1
	va_list args
	args.va_start(v1)
	while 1
		void* v=args.va_arg(void*)
		if v==End => break
		mp[]=v
	args.va_end()
	return mp
}
map* xmap(char* k1=End, void* ...){
	mp={}
	if k1==End => return mp
	va_list args
	args.va_start(k1)
	void* v=NULL
	void* k=k1
	while 1
		v=args.va_arg(void*)
		if v==End => "Value for key $k not provided in xmap".fox_error()
		mp[k]=v
		k=args.va_arg(char*)
		if !k || k==End => break
	args.va_end()
	return mp
}
char* new_str(int len) => return fox_alloc(len+1,String)
map* new_map(){
	map* ret=map.sizeof().fox_alloc(Map)
	ret->type=Map
	return ret
}
map* new_vec(){
	map* ret=map.sizeof().fox_alloc(Vector)
	ret->type=Vector
	return ret
}
int key_eq(map* mp,int idx,char* id){
	id.assert()
	assert(idx>=0 && idx<mp->len)
	char* key=mp.map_key(idx)
	if key.is_str() => return key===id.is_str()
	return id==key
}
int key_hash(char* id) => return id.is_str() ? str_hash((unsigned char*)id) : id.is_int()
int map_has_key(map* mp,char* id){
	if !id||!mp => return 0
	assert(mp.is_map())
	if !mp->len => return 0
	if mp.ptr_type()==Vector
		if id.is_str() => return 0
		idx=id.is_int()
		if idx<1||idx>mp->len => return 0
		return idx
	
	hash=id.key_hash()
	hash=hash & (mp.map_size()-1)
	int idx=mp->pairs[hash].hkey
	while idx>0
		if mp.key_eq(idx-1,id) => return idx
		idx=mp->pairs[idx-1].nextid
	
	return 0
}
map* vec_realloc(map* mp,int extra){
	size=mp.map_size()
	int req=mp->len+extra
	if req<=size => return mp
	if !size => size=2
	while(size<req) size*=2
	mp->vars=fox_realloc((char*)mp->vars,size*sizeof(void*),Cell)
	return mp
}
map* vec_add(map* mp,void* v){
	if !mp => return mp
	if mp->type!=Vector => return mp.add(NULL,v)
	mp.vec_realloc(1)
	mp->len++
	mp->vars[mp->len-1]=v
	return mp
}
map* set(map* mp,int idx,void* val){
	if idx<0 => return mp
	if mp.ptr_type()==Map => mp->pairs[idx].val=val
	else mp.vec_set(idx+1,val)
	return mp
}
long long is_int(void* v){
	if !v.is_i() => return 0
	size_t val=((size_t)v >> 63) & 1 ? 3 : 0;
	return (long long)((((size_t)v) & ~(3ll<<61)) | ((val & 3ll)<<61));
}
double is_double(void* v){
	if !v.is_f() => return v.is_int()
	size_t val=(((size_t)v) >> 60) & 1 ? 1 : 2;
	val=(size_t)((((size_t)v) & ~(3ll<<61)) | ((val & 3ll)<<61));
	return *(double*)&val;
}
void* int_var(size_t i){
	return (void*)((i & ~(3ll<<61)) | ((2ll & 3ll)<<61));
}
void* double_var(double f){
	return (void*)(((*(size_t*)&f) & ~(3ll<<61)) | ((1ll & 3ll)<<61));
}
int has_id(map* mp,int idx)		=> return idx>=0 && idx<mp->len
void* map_id(map* mp,int idx){
	if !mp => return NULL
	if !mp.is_map() => ("Error! not map "..mp.to_str().str_quote()).px(); assert(0)
	assert(mp.is_map())
	if idx<0 || idx>=mp->len => return NULL
	return mp->type==Vector ? mp->vars[idx] : mp->pairs[idx].val
}
int map_len(map* mp){
	if !mp => return 0
	assert(mp.is_map())
	return mp->len
}
char* map_key(map* mp,int idx)	=> return idx<0 ? NULL : (mp.ptr_type()==Map ? mp->pairs[idx].id : (idx+1).int_var())
char* is_str(void* v){
	if !v || v.is_num() => return NULL
	type=ptr_type(v);
	return type==String || type==Blob ? v : NULL
}
char* is_blob(void* v)	=> return ptr_type(v)==Blob ? v: NULL
map* is_vec(void* v)			=> return ptr_type(v)==Vector ? v: NULL
map* is_hash(void* v)			=> return ptr_type(v)==Map ? v: NULL
map* is_map(void* v)			=> return ptr_type(v)>=Map ? v: NULL
double to_double(void* v){
	if v.is_str()
		ret=0.0
		if !v => return ret
		sscanf(v,"%lf",&ret)
		return ret
	return v.is_double()
}
long long to_int(void* v){
	if v.is_str()
		long long ret=0
		sscanf(v,"%lld",&ret)
		return ret
	return v.is_int()
}
int next(map* mp,int idx,char** key=NULL,void** val=NULL){
	idx++
	if !mp||idx>=mp->len => return -1
	while idx<mp->len && mp[idx]==(char*)&skip => idx++
	if idx>=mp->len => return -1
	if key => *key=mp.map_key(idx)
	if val => *val=mp[idx]
	return idx
}
int stoi(char* str){
	if !str => return 0
	return atoi(str)
}
map* globals() => return _globals
int mem_used(int block_size=0,int type=0){
	ret=0
	pg.each_mem(mem_i){
		if (!block_size || block_size==pg->block_size)// && (!type || type==pg->type)
			ret+=(pg->blocks-pg->free)*pg->block_size
	}
	return ret
}
mempage* ptr_page(void* ptr){
	if !ptr || !_gcdata.total_pages || (char*)ptr<_gcdata.pages[0].page || (char*)ptr>_gcdata.pages[_gcdata.total_pages-1].types => return NULL
	int lo=-1
	int up=_gcdata.total_pages
	while up-lo>1
		int mid=(lo+up)/2
		if ptr>=(void*)_gcdata.pages[mid].page && ptr<(void*)_gcdata.pages[mid].types
			return &_gcdata.pages[mid]
		else if ptr<(void*)_gcdata.pages[mid].page
			up=mid
		else
			lo=mid
	return NULL
}
void* block_ptr(int block,mempage* pg) => return pg->page+pg->block_size*block
int ptr_block(void* ptr,mempage* pg) => return ((char*)ptr-pg->page)/pg->block_size
int ptr_type(void* ptr){
	if !ptr => return Null
	if ptr.is_i() => return Int
	if ptr.is_f() => return Double
	mempage* pg=ptr.ptr_page()
	if !pg => return String
//	if pg->type => return pg->type
	return pg->types[ptr.ptr_block(pg)] & 31
}
int cell2_mark(Mapcell* pairs,int size){
	for i=0;i<size;i++
		if !pairs[i].id.is_num() => gc_mark(pairs[i].id)
		gc_mark(pairs[i].val)
	
	return 0
}
int cell_mark(void** pairs,int size){
	for i=0;i<size;i++
		gc_mark(pairs[i])
	
	return 0
}
int gc_mark(void* ptr){
	if !ptr => return 0
	mempage* pg=ptr.ptr_page()
	if !pg => return 0
	int head=ptr.ptr_block(pg).block_head(pg)
	int len=head.block_len(pg)
	if pg->types[head] & (1<<7) => return 1
	int type=pg->types[head]
	for int i=0; i<len; i++ => pg->types[head+i] |= (1<<7)
	ptr=head.block_ptr(pg)
	if type==Cell => cell_mark((void**)ptr,ptr.mem_size()/sizeof(void*))
	else if type==Cell2 => cell2_mark((Mapcell*)ptr,ptr.mem_size()/Mapcell.sizeof())
	else if type==Map => gc_mark(((map*)ptr)->pairs)
	else if type==Vector => gc_mark(((map*)ptr)->vars)
	else if type==Index||type==Keys => assert(0)
	return 1
}
int sweep_page(mempage* pg){
	ret=0
	pg->free=0
	for i=0;i<pg->blocks;i++
		if !(pg->types[i] & (1<<7))
			if pg->types[i]
				if (pg->types[i] & 31) !=Tail => ret++
				pg->types[i]='\0'
				memset(pg->page+i*pg->block_size,0,pg->block_size)
			pg->free++
			continue
		else
			pg->types[i] &= ~(1<<7)
	return ret*pg->block_size
}
void* data_delete(void* data,int idx,int size,int len) => return data.data_shift(idx+1,-1,size,len)
void* data_insert(void* data,int idx,int size,int len){
	data.data_shift(idx,1,size,len)
	memset((char*)data+idx*size,0,size)
	return data
}
void* data_shift(void* data,int idx,int shift,int size,int len){
	if idx>=len => return data
	memmove((char*)data+(idx+shift)*size,(char*)data+idx*size,(len-idx)*size)
	return data
}
int cmp_page(const void* pg1,const void* pg2){
	if ((mempage*)pg1)->page<((mempage*)pg2)->page => return -1
	return 1
}
void reindex_pages(){
	char* lastpage=NULL
	qsort(_gcdata.pages,_gcdata.total_pages,sizeof(mempage),cmp_page)
	pg.each_mem(mem_i){
		pg->idx=mem_i
		assert(!lastpage || pg->page>lastpage)
		lastpage=pg->page
	}
}
mempage* no_page(int no){
	pg.each_mem(idx) => if pg->no==no => return pg
	assert(0)
	return NULL
}
struct mempage* new_page(int block_size,int blocks){
	size=block_size*blocks
	char* page=(size+blocks).malloc()
	_gcdata.pages=realloc(_gcdata.pages,(_gcdata.total_pages+1)*sizeof(mempage))
	_gcdata.pages=_gcdata.pages.data_insert(_gcdata.total_pages,sizeof(mempage),_gcdata.total_pages)
	mempage* ret=&_gcdata.pages[_gcdata.total_pages]
	_gcdata.total_pages++
	ret->page=page
	int no=ret->no=_gcdata.page_no++
	reindex_pages()
	ret=no.no_page()
	assert((long long)ret->page>0)
	ret->blocks=blocks
	ret->free=blocks
	ret->block_size=block_size
	ret->types=ret->page+size
	memset(ret->types,0,blocks)
	ret.index_free_space()
	_gcdata.curr_mem+=size+blocks*sizeof(char)
	_gcdata.max_mem=max(_gcdata.max_mem,_gcdata.curr_mem)
	return ret
}
int comp_iptr(const void* sp1,const void* sp2){
	// -1: move sp1 left, +1: move right
	int* i1=*(int**)sp1
	int* i2=*(int**)sp2
	if *i1 > *i2 => return -1
	if *i1 < *i2 => return 1
	if i1 > i2 => return 1
	if i1 < i2 => return -1
	return 0
}
mempage* index_free_space(mempage* pg){
	if pg->blocks==1 => return pg
	int free_len=0
	int maxchain=max(pg->blocks/20,1)
	no=0
	int** chains=realloc(pg->chains.vars,maxchain*sizeof(int*))
	for i=0;i<=pg->blocks;i++
		if i<pg->blocks && !pg->types[i]
			free_len++
		else if free_len
			if free_len<MIN_CHAIN
				free_len=0
				*(int*)(pg->page+(i-1)*pg->block_size)=free_len
				continue
			if no>=maxchain
				maxchain*=2
				chains=chains.realloc(maxchain*sizeof(int*)*2)
			chains[no]=(int*)(pg->page+(i-free_len)*pg->block_size)
			*chains[no]=free_len
			no++
			free_len=0
	assert(free_len==0)
	qsort(chains,no,sizeof(int*),comp_iptr)
	pg->chains.len=no
	pg->chains.vars=(void**)chains
	return pg
}
void* chain_alloc(mempage* pg, int size, int type, char* ptr=NULL){
	blocks=size.size_blocks(pg)
	chainid=-1
	lo=-1
	int hi=pg->chains.len
	if !ptr
		while hi-lo>1
			chainid=(hi+lo)/2
			if blocks==*(int*)(pg->chains.vars[chainid]) => break
			else if blocks<*(int*)(pg->chains.vars[chainid]) => lo=chainid
			else hi=chainid
		if hi-lo<2
			if lo==-1 => return NULL
			else chainid=lo
		assert(chainid>=0)
		assert(chainid<pg->chains.len)
		ptr=pg->chains.vars[chainid]
		assert(*(int*)ptr>=blocks)
	else
		if ptr<pg->page || ptr>=pg->types => return NULL
		if ptr.ptr_type() => return NULL
		if *(int*)ptr<blocks => return NULL
		if *(int*)ptr>=MIN_CHAIN
			while hi-lo>1
				int mid=(hi+lo)/2
				match=comp_iptr(&ptr,&(pg->chains.vars[mid]))
				if !match
					chainid=mid
					break
				else if match<0 => hi=mid
				else lo=mid
			assert(chainid>=0)
	if chainid>=0
		pg->chains.vars=pg->chains.vars.data_delete(chainid,sizeof(int*),pg->chains.len)
		pg->chains.len--
	int rest=*(int*)ptr-blocks
	assert(rest>=0)
	void* shifted=ptr+pg->block_size*blocks
	if rest
		*(int*)shifted=rest
	if rest>=MIN_CHAIN
		assert(chainid>=0)
		lo=-1
		hi=pg->chains.len
		while hi-lo>1
			int mid=(hi+lo)/2
			if comp_iptr(&shifted,&(pg->chains.vars[mid]))==1 => lo=mid
			else hi=mid
		assert(hi>=0 && hi<=pg->chains.len)
		if hi => assert(*(int*)shifted<=*(int*)(pg->chains.vars[hi-1]))
		if hi<pg->chains.len => assert(*(int*)shifted>=*(int*)(pg->chains.vars[hi]))
		pg->chains.vars=pg->chains.vars.data_insert(hi,sizeof(int*),pg->chains.len)
		pg->chains.vars[hi]=shifted
		pg->chains.len++
	block=ptr.ptr_block(pg)
	pg->types[block]=type
	type |= (1<<6)
	for int i=1;i<blocks;i++
		assert(!pg->types[block+i])
		pg->types[block+i]=type
	pg->free-=blocks
	memset(ptr,0,blocks*pg->block_size)
	return ptr
}
void* page_alloc(mempage* pg,int size,int type,int* full=NULL){
	if pg->blocks==1
		if !pg->free || size>pg->block_size || size<pg->block_size*.4 => return NULL
		pg->types[0]=type
		pg->free=0
		memset(pg->page,0,size);
		return pg->page

	int block_size=pg->block_size
	int blocks=(size+block_size-1)/block_size
	blocks.assert()

	if block_size>16 && size<block_size/2
		return NULL
	if block_size<1024*4 && blocks>32
		return NULL
	if blocks > 0.5 * pg->blocks
		return NULL

	if full && (block_size==16 || size>=block_size) && (block_size==1024*4||blocks<16) && blocks<0.4*pg->blocks => (*full)++
	return pg.chain_alloc(size,type)
}
int gc_sweep(){
	_gcdata.curr_used=0
	ret=0
	pg.each_mem(mem_i){
		ret+=pg.sweep_page()
		if pg->free==pg->blocks
			pg->abandoned++
			if pg->abandoned>2
				pg.free_page()
				mem_i--
				continue
		else
			pg->abandoned=0
		_gcdata.curr_used+=(pg->blocks-pg->free)*pg->block_size
		pg.index_free_space()
	}	
	_gcdata.max_used=max(_gcdata.curr_used,_gcdata.max_used)
	return ret
}
map* root_ptrs(){
	void* stack_end=_globals
	static map ret={0}
	void* ptr=(void*)&stack_end
	if !_gcdata.stack_head => "gc_start() was not called fox_at start of application".printf(); exit(-1)
	int size=((void*)_gcdata.stack_head-ptr)/sizeof(void*)
	ret.vars=size<0 ? _gcdata.stack_head : ptr
	ret.len=size.abs()+1
	ret.type=Vector
	return &ret
}
int fox_gc(){
	pre_usage=mem_used()
	// commenting off setjmp() doesn't make any diff even in -O3
	jmp_buf regs={0}
	setjmp(regs)
	roots=root_ptrs()
	for int i=0; i<roots->len; i++ => roots->vars[i].gc_mark()
	int freed=gc_sweep()
	_gcdata.gcruns++
	percent=pre_usage ? freed*100/pre_usage : 100
	if percent <=5 => _gcdata.gcwaste++
	return percent
}
int gc_runs() => return _gcdata.gcruns
int gc_time() => return _gcdata.gctime/1000
int gc_end(){
	_globals=NULL; _clockstart=0;
	mempage* pg=_gcdata.pages
	pg.each_mem(i)
		pg->page.free()
	
	_gcdata.pages.free()
	memset(&_gcdata,0,sizeof(_gcdata))
	return 0
}
mempage* free_page(mempage* pg){
	int idx=pg->idx
	pg->page.free()
	_gcdata.pages=_gcdata.pages.data_delete(pg->idx,mempage.sizeof(),_gcdata.total_pages)
	_gcdata.total_pages--
	reindex_pages()
	return idx < _gcdata.total_pages ? &_gcdata.pages[idx] : NULL
}
int str_len(char* str){
	if !str => return 0
	int type=str.ptr_type()
	if type==Blob => return str.blob_size()
	if type==String => return str.strlen()
	return 0
}
int block_len(int block,mempage* pg){
	if !pg => return 0
	ret=1
	for i=block+1;i<pg->blocks;i++
		if pg->types[i] & (1<<6)
			ret++
		else break
	return ret
}
int mem_size(void* ptr){
	mempage* pg=ptr.ptr_page()
	if !pg => return 0
	block=ptr.ptr_block(pg)
	assert(!(pg->types[block] & (1<<6)))
	return pg->block_size*block.block_len(pg)
}
void* expand_inplace(char* ptr,char type,int size,int extra){
	mempage* pg=ptr.ptr_page()
	if pg->blocks==1
		assert(ptr==pg->page)
		newsize=size+extra
		assert(newsize>pg->block_size)
		if type==String
			newsize*=2
		newsize=(newsize+8-1) & ~(8-1) //roundup
		pg->block_size=newsize
		pg->page=pg->page.realloc(newsize+1)
		pg->types=pg->page+newsize
		pg->types[0]=type
		memset(pg->page+size,0,newsize-size)
		void* ret=pg->page
		reindex_pages()
		return ret
	void* ret=chain_alloc(pg,extra,type,ptr+pg->block_size)
	if !ret => return NULL
	pg->types[ret.ptr_block(pg)]=type|(1<<6)
	return ptr
}
int size_blocks(size_t size,mempage* pg) => return (size + pg->block_size - 1) / pg->block_size
void* fox_realloc(void* ptr,size_t size,int type){
	assert(size)
	assert(size<MAXMEM)
	if !ptr
		return size.fox_alloc(type)
	void* head=ptr.ptr_head()
	int oldsize=head.mem_size()
	int offset=head ? (char*)ptr-(char*)head : 0
	size+=offset
	if head
		if oldsize>=size
			return ptr
		void* ret=head.expand_inplace(type,oldsize,size-oldsize)
		if ret => return ret+offset	
	void* ret=size.fox_alloc(type)
	ret.assert()
	assert(oldsize || type==String)
	oldsize ? ret.memcpy(ptr,oldsize) : ret.memcpy(ptr,ptr.strlen()+1)
	return ret+offset
}
void* fox_alloc(size_t size,int type){
	if !_gcdata.stack_head => "GC not started!!!".printf(); exit(-1);
	if _gcdata.inalloc => "fox_error!!! Recursive fox_alloc() call".printf(); exit(-1);
	_gcdata.inalloc=1
	assert(size<MAXMEM)
	struct timeval gc_start=microtime()
	void* ret=size._xalloc(type)
	if !ret => "%ld byte allocation failed.".printf(size); exit(-1)
	int time=gc_start.elapsed()
	_gcdata.gctime+=time
	_gcdata.gcmax=max(_gcdata.gcmax,time)
	assert(!((char*)ret)[size-1])
	_gcdata.inalloc=0
	return ret
}
void* new_alloc(size_t size,int type){
	int bsize=size.block_size()
	if !bsize => return size.new_page(1).page_alloc(size,type)
	return bsize.new_page(max(ceil_pow2((mem_used(bsize,type)+size*2))/bsize,64*1024/bsize)).page_alloc(size,type)
}
void* _xalloc(size_t size,int type){
	if !_gcdata.pages => return size.new_alloc(type)
	if size>256*256*16 => return size.new_alloc(type)
	char* ret=NULL
	int full=0
	pg.each_mem(mem_i){
		if((ret=pg.page_alloc(size,type,&full))) return ret
	}
	if !full => return size.new_alloc(type)
	freed=fox_gc()
	if freed <=5 => return size.new_alloc(type)
	pg.each_mem(mem_i2) if((ret=pg.page_alloc(size,type))) return ret
	return size.new_alloc(type)
}
int block_size(int size){
	if size <= 256 => return 16
	if size <= 256*16 => return 256
	if size <= 256*256 => return 256*16
	return 0
}
void start_time() => _gcdata.time=microtime()
void end_time() => _total_time+=_gcdata.time.elapsed()
int run_time() => return _gcdata.run_time.elapsed()/1000
int total_time() => return _total_time/1000
void time_max(){
	int curr=_gcdata.time.elapsed()
	_total_time=max(_total_time,curr)
}
struct timeval microtime(){
	struct timeval ret={0}
	gettimeofday(&ret,NULL)
	return ret
}
int elapsed(struct timeval from){
	struct timeval upto=microtime()
	return (upto.tv_sec-from.tv_sec)*1000000+(upto.tv_usec-from.tv_usec)
}
int map_size(map* mp){
	if !mp => return 0
	return ceil_pow2(mp->len)
}
int ceil_pow2(int i){
	if !i => return 0
	i--
	int ret=2
	while(i>>=1) ret<<=1
	return ret
}
map* add(map* mp,void* k,void* v) => return mp->type==Vector ? mp.vec_set(k.is_int(),v) : mp.map_add(k,v)
map* vec_set(map* mp,int idx,void* v){//1 based
	if !mp => return mp
	if mp->type!=Vector => return mp.add(idx.int_var(),v)
	if idx>0 && idx<=mp->len => mp->vars[idx-1]=v; return mp
	if idx<1 => return mp.vec_add(v)
	diff=idx-mp->len
	while diff>1
		mp.vec_add(NULL)
		diff--
	return mp.vec_add(v)
}
map* map_add(map* mp,char* key,void* v){
	if !mp => return mp
	assert(mp.ptr_type()==Map)
	int idx=mp.map_has_key(key)
	if idx
		mp->pairs[idx-1].val=v
		return mp
	
	int reindex=0
	if mp->len>=mp.map_size()
		mp->pairs=mp.map_size() ? fox_realloc((char*)mp->pairs,2*mp.map_size()*Mapcell.sizeof(),Cell2)
			: fox_alloc(2*Mapcell.sizeof(),Cell2)
		reindex=1
	
	mp->pairs[mp->len].val=v
	mp->pairs[mp->len].id=key
	mp->pairs[mp->len].nextid=-1
	mp->len++
	reindex ? mp.map_reindex() : mp.map_index(mp->len-1)
	return mp
}
int map_nextno(map* mp){
	for int i=mp->len-1; i>=0; i--
		if mp->pairs[i].id.is_i() => return mp->pairs[i].id.is_int()
	return 0
}
map* map_index(map* mp,int idx){
	if !mp => return mp
	assert(idx>=0 && idx<mp->len)
	mp->pairs[idx].nextid=-1
	char* id=mp->pairs[idx].id
	if !id => mp->pairs[idx].id=(mp.map_nextno()+1).int_var()
	int i=key_hash(mp->pairs[idx].id)
	i=i & (mp.map_size()-1)
	if !mp->pairs[i].hkey => mp->pairs[i].hkey=idx+1
	else
		i=mp->pairs[i].hkey
		assert(i>0 && i<=mp->len)
		while mp->pairs[i-1].nextid>0
			i=mp->pairs[i-1].nextid
			if i==idx+1 => assert(0)
		mp->pairs[i-1].nextid=idx+1
	return mp
}
map* map_reindex(map* mp){
	if !mp => return mp
	for int i=0;i<mp.map_size();i++
		mp->pairs[i].nextid=mp->pairs[i].nextid ? -1 : 0
		mp->pairs[i].hkey=0
	
	mp.each ,,i => mp.map_index(i)
	return mp
}
char* null_str(char* in) => return in ? in : ""
map* ptrs_vec(void** ptrs,int len){
	ret=[]
	ret->len=len
	ret->vars=ptrs
	return ret
}
int init_gc(void** sp){
	_clockstart=clock_cycles()
	_gcdata.run_time=microtime()
	_gcdata.stack_head=sp
	*sp=_globals={}
	SIGSEGV.signal(fox_signal_handler)
	SIGABRT.signal(fox_signal_handler)
	init_rand()
	return 0
}
int exec(char* cmd,char** output=NULL){
	FILE* fp
	char buff[2048]
	buff[sizeof(buff)-1]='\0'
	fp=cmd.popen(:r)
	if !fp => "Failed to run $cmd".fox_error(); return -1
	char* ret=NULL
	while(buff.fgets(buff.sizeof()-1,fp)) => !output ? buff.px(0) : (ret.=buff)
	int status=fp.pclose()
	status=status.WEXITSTATUS()
	if output => *output=ret
	return status
}
size_t clock_cycles(){
	unsigned int lo,hi;
	asm volatile (:rdtsc : "=a" (lo), "=d" (hi));
	return ((size_t)hi << 32) | lo;
}
void* ptr_head(void* ptr){
	mempage* pg=ptr.ptr_page()
	if !pg => return NULL
	return ptr.ptr_block(pg).block_head(pg).block_ptr(pg)
}
int block_head(int no,mempage* pg){
	while pg->types[no] & (1<<6) => assert(no>0); no--
	return no
}
void init_rand() => srand(NULL.time()*2817635252+_gcdata.run_time.tv_usec)
void* map_val(map* mp,char* key){
	if !mp||!key => return NULL
	assert(mp.ptr_type()==Map)
	i=mp.map_has_key(key)
	return i ? mp->pairs[i-1].val : NULL
}
map* argv_map(char** argv,int argc){
	ret=[]
	ret->len=argc
	ret->vars=(void**)argv
	return ret
}
