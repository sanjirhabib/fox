#line 2 "src/schema.fox"

#include <core.h>
#include <sql.h>
#include <schema.h>
#include <tsv.h>
#include <foxparser.h>

//int run(map* args){
//	_globals.dbs.nuaim="/web/habibur/kitab/db/nuaim.db"
//	//:nuaim.schema_write("nuaim.schema")
////	"nuaim.schema".schema_load(:nuaim).px()
//	:nuaim.schema_sql("nuaim.schema")
//	:nuaim.schema_sync("nuaim.schema")
//	return 0
//}
void schema_sync(char* db,char* file) => file.schema_load().tbls_sync_sqls(db.lite_schema()).sqls_exec(db)
void schema_sql(char* db,char* file) => file.schema_load().tbls_sync_sqls(db.lite_schema()).map_join(";\n").px()
char* schema_write(char* db, char* file='') => return db.lite_schema().schema_str().write_file(file)
map* schema_load(char* file,char* db=''){
	ret={}
	cols={}
	name=''
	file.tsv_load().each row
		if row.table.str_len()
			if name => ret[name]=cols.cols_table(name,db)
			name=row.table
			cols={}
			continue
		op=row.cols.str_cols()[0]
		cols[op.name]=op
	if name => ret[name]=cols.cols_table(name,db)
	return ret
}
char* schema_str(map* in){
	ret=[]
	in.each prop,tbl
		ret[]={table: tbl, cols: ""}
		prop.cols.each col
			ret[]={cols: col.col_str() } 
	return ret.rows_str("table,cols".str_cols())
}
char* rows_str(map* in,void* cols=NULL){
	if !in || !in.map_len() => return ''
	cols=cols.str_cols().map_keys()
	if !cols => cols=in[0].map_keys()
	if !cols => return ''
	ret=cols.map_join("\t").."\n"
	in.each row
		rs=[]
		cols.each col
			rs[]=row[col]
		ret.=rs.map_join("\t").."\n"
	return ret
}
char* col_str(map* in){
	if !in => return ''
	ret=in.name.str_dup()
	in.each v, n
		if n.is_word("db table name") => continue
		if n===:size && in.type.type_size()==v.to_int() => continue
		ret.=" $n=$v"
	return ret
}
//map* lite_schema(char* db){
//	ret={}
//	db.lite_tables().each tbl
//		ret[tbl]=tbl.lite_cols(db)
//	return ret
//}
//map* lite_tables(char* db){
//	return "select name from sqlite_master where type='table' and name not in ('sqlite_sequence', '_syncing', 'search', 'search_data', 'search_idx', 'search_content', 'search_docsize', 'search_config') order by 1"
//		.sql_pairs(db)
//}
//map* lite_cols(char* tbl,char* db){
//	ret={}
//	"pragma table_info ($tbl)".sql_rows(db).each row
//		name=row.name.str_lower()
//		ret[name].name=name
//		type=row.type.str_split("(")
//		ret[name].type=type[0]
//		if type[1]
//			ret[name].size=type[1].str_trim(")").to_int()
//		if row.pk.to_int()
//			ret[name].pkey=:pkey
//		if !row.notnull.to_int()
//			ret[name].isnull=1
//		if row.dflt_value.str_len() && row.dflt_value !== "''"
//			ret[name].default=row.dflt_value
//	return ret
//}
char* sql_rename(char* from,char* into) => return "alter table $from rename to $into"
int type_distance(char* type1,char* type2){
	if type1===type2 => return 0
	subs1=subtypes(type1)
	subs2=subtypes(type2)
	len1=subs1.map_len()
	len2=subs2.map_len()
	i=0
	while i<len1 && i<len2
		i++
		if subs1[i-1]!==subs2[i-1] => i--; break
	return len1 + len2 - 2 * i
}
map* cols_match(map* from, map* into){
	ret={}
	ret2={}
	into.each op,f,i
		if from[f]
			ret[f]=f
			ret2[f]=f
	into.each op1,f1,i1
		if ret[f1] => continue
		minid=0
		mindist=0
		from.each op2,f2,i2
			if ret2[f2] => continue
			dist=op2.type.type_distance(op1.type)
			if !minid => minid=i2; mindist=dist
			else if dist<mindist => minid=i2
		if !minid => break
		ret[f1]=from.map_key(minid)
			
	return ret
}
char* nearest_table(map* tbls,map* tbl){
	match={}
	tbls.each t,name
		int score=abs(t.cols.map_len()-tbl.cols.map_len())
		tbl.cols.each col,f
			if t.cols[f].type!==col.type => score--
		match[name]=score
	if !match->len => return ''
	match.map_sort(-1)
	return match.map_key(0)
}
map* lite_trigger_slno(char* name, char* pkey, char* by=NULL){
	nby=by and " and $by=new.$by"
	oby=by and " and $by=old.$by"
	by&&=" where $by=new.$by"
	return [
		"drop trigger if exists $(name)_slno_insert_null",
		"create trigger $(name)_slno_insert_null after insert on $name when new.slno+0=0 or abs(new.slno+0)>(select count(*) from $name$by) begin
			update $name set slno=1+(select count(*) from $name where $pkey!=new.$pkey$nby) where $pkey=new.$pkey;
		end",
		"drop trigger if exists $(name)_slno_insert_negetive",
		"create trigger $(name)_slno_insert_negetive after insert on $name when new.slno<0 and abs(new.slno)<=(select count(*) from $name$by) begin
			update $name set slno=slno+.5 where slno>=(select count(*) from $name$by)+new.slno$nby;
			update $name set slno=slno+.5 where slno>=(select count(*) from $name$by)+new.slno$nby;
			update $name set slno=(select count(*) from $name$by)+new.slno+1 where $pkey=new.$pkey;
		end",
		"drop trigger if exists $(name)_slno_insert_positive",
		"create trigger $(name)_slno_insert_positive after insert on $name when new.slno>0 and new.slno<=(select count(*) from $name$by) begin
			update $name set slno=slno+.5 where slno>=new.slno and $pkey!=new.$pkey$nby;
			update $name set slno=slno+.5 where slno>=new.slno and $pkey!=new.$pkey$nby;
		end",
		"create trigger $(name)_slno_delete after delete on $name begin
			update $name set slno=slno-.5 where slno>old.slno$oby;
			update $name set slno=slno-.5 where slno>old.slno$oby;
		end",
		"create trigger $(name)_slno_update_null after update on $name when new.slno is null or new.slno=0 or new.slno='' or abs(new.slno)>(select count(*) from $name$by) begin
			update $name set slno=slno-.5 where slno>old.slno$oby;
			update $name set slno=slno-.5 where slno>old.slno$oby;
			update $name set slno=(select count(*) from $name$by) where $pkey=new.$pkey;
		end",
		"create trigger $(name)_slno_update_negetive after update on $name when new.slno<0 and new.slno>=-1*(select count(*) from $name$by) begin
			update $name set slno=slno-.5 where slno>old.slno$oby;
			update $name set slno=slno-.5 where slno>old.slno$oby;
			update $name set slno=slno+.5 where slno>=(select count(*) from $name$by)+new.slno$nby;
			update $name set slno=slno+.5 where slno>=(select count(*) from $name$by)+new.slno$nby;
			update $name set slno=(select count(*) from $name$by)+new.slno where $pkey=new.$pkey;
		end",
		"create trigger $(name)_slno_update_positive after update on $name when new.slno>0 and old.slno>0 and abs(new.slno-old.slno)>=1 and new.slno<=(select count(*) from $name$by) begin
			update $name set slno=slno-.5 where slno>old.slno and $pkey!=new.$pkey$oby;
			update $name set slno=slno-.5 where slno>old.slno and $pkey!=new.$pkey$oby;
			update $name set slno=slno+.5 where slno>=new.slno and $pkey!=new.$pkey$nby;
			update $name set slno=slno+.5 where slno>=new.slno and $pkey!=new.$pkey$nby;
		end;
		"]
}
map* lite_trigger_tree(char* name,char* pkey){
	return [
		"drop trigger if exists $(name)_tree_insert_null",
		
		"create trigger $(name)_tree_insert_null after insert on $name when new.parent is null or new.parent='' begin
		update $name set lft=(select coalesce(max(rgt),0) from $name where $pkey!=new.$pkey)+1,rgt=(select coalesce(max(rgt),0) from $name where $pkey!=new.$pkey)+2 where $pkey=new.$pkey;
		end",
	
		"drop trigger if exists $(name)_tree_insert",

		"create trigger $(name)_tree_insert after insert on $name when new.parent is not null and length(new.parent)>0 begin
		update $name set lft=(select rgt from $name where $pkey=new.parent),rgt=(select rgt from $name where $pkey=new.parent)+1 where $pkey=new.$pkey;
		update $name set lft=lft+2 where lft>(select rgt from $name where $pkey=new.parent);
		update $name set rgt=rgt+2 where rgt>=(select rgt from $name where $pkey=new.parent) and $pkey!=new.$pkey;
		end",

		"drop trigger if exists $(name)_tree_delete",

		"create trigger $(name)_tree_delete before delete on $name begin
		update $name set lft=lft-(old.rgt-old.lft)-1 where lft>old.rgt;
		update $name set rgt=rgt-(old.rgt-old.lft)-1 where rgt>old.rgt;
		delete from $name where lft>old.lft and lft<old.rgt;
		end",

		"drop trigger if exists $(name)_tree_update_null",

		"create trigger $(name)_tree_update_null after update of parent on $name when new.parent!=old.parent and (new.parent is null or length(new.parent)=0) begin
		update $name set lft=lft+(select max(rgt) from $name)-old.lft+1,rgt=rgt+(select max(rgt) from $name)-old.lft+1 where lft>=old.lft and lft<=old.rgt;
		update $name set lft=lft-(old.rgt-old.lft)-1 where lft>old.rgt;
		update $name set rgt=rgt-(old.rgt-old.lft)-1 where rgt>old.rgt;
		end",
	
		"drop trigger if exists $(name)_tree_update_right",

		"create trigger $(name)_tree_update_right after update of parent on $name when new.parent is not null and length(new.parent)>0 and old.lft<(select lft from $name where $pkey=new.parent) begin
		update $name set lft=case when lft>old.rgt and lft<(select rgt from $name where $pkey=new.parent) then lft-old.rgt+old.lft-1 when lft>=old.lft and lft<=old.rgt then lft+(select rgt from $name where $pkey=new.parent)-old.rgt-1 else lft end;
		update $name set rgt=case when rgt>old.rgt and rgt<(select rgt from $name where $pkey=new.parent) then rgt-old.rgt+old.lft-1 when rgt>=old.lft and rgt<=old.rgt then rgt+(select rgt from $name where $pkey=new.parent)-old.rgt-1 else rgt end;
		end",
		
		"drop trigger if exists $(name)_tree_update_left",

		"create trigger $(name)_tree_update_left after update of parent on $name when new.parent is not null and length(new.parent)>0 and old.lft>(select lft from $name where $pkey=new.parent) begin
		update $name set lft=case when lft<old.lft and lft>=(select rgt from $name where $pkey=new.parent) then lft+old.rgt-old.lft+1 when lft>=old.lft and lft<=old.rgt then lft-old.lft+(select rgt from $name where $pkey=new.parent) else lft end;
		update $name set rgt=case when rgt<old.lft and rgt>=(select lft from $name where $pkey=old.$pkey) then rgt+old.rgt-old.lft+1 when rgt>=old.lft and rgt<=old.rgt then rgt-old.lft+(select lft from $name where $pkey=old.$pkey) else rgt end;
		end"
	]
}

map* tbls_sync_sqls(map* new_tbls,map* old_tbls){
	if !new_tbls => "sync_sql() final table list is blank!".fox_error()
	newtbls={}
	oldtbls={}
	old_tbls.map_del_key(:_syncing).map_compact()
	new_tbls.map_del_key(:search).map_compact()
	old_tbls.each val,key => if !new_tbls[key] => oldtbls[key]=val
	match={}
	new_tbls.each val,key
		if !old_tbls[key] => newtbls[key]=val
		else match[key]=key
	newtbls.each tbl,name
		if !oldtbls->len => break
		match[name]=oldtbls.nearest_table(tbl)
		oldtbls.map_del_key(match[name]).map_compact()
	sqls=[]
	match.each oldt,newt
		changes=new_tbls[newt].sync_sqls(old_tbls[oldt])
		if oldt!==newt
			"= $oldt renamed $newt".px()
		else if changes
			"= $newt updated".px()
		sqls.vec_merge(changes)
	newtbls.each newt,name
		"+ $name created".px()
		sqls[]=newt.create_sql()
		sqls.vec_merge(newt.create_index_sqls())
//		sqls.vec_merge(newt.tbl_trigger_sqls())
	oldtbls.each oldt,name
		"- $name dropped".px()
		sqls[]=oldt.name.drop_sql()
	return sqls
}
map* tbl_cols(char* table,char* db) => return db.lite_schema()[table].cols
map* sync_sqls(map* newt,map* oldt){
	if oldt.create_sql()===newt.create_sql() => return NULL	
	match=oldt.cols.cols_match(newt.cols)
	ret=[]
	ret[]=:_syncing.drop_sql()
	ret[]=newt.create_sql(:_syncing)
	ret[]="insert into _syncing ("..match.map_keys().map_join(", ")..") select "..match.map_join(", ").." from "..oldt.name
	ret[]=oldt.name.drop_sql()
	ret[]=:_syncing.sql_rename(newt.name)
	ret
		.vec_merge(newt.create_index_sqls())
		.vec_merge(newt.tbl_trigger_sqls())
	return ret	
}
map* trigger_sqls(char* tbl,char* db) => return db.lite_schema()[tbl].tbl_trigger_sqls()
void* id_update(void* ids,char* tbl,char* db,map* row){
	ids=ids.id_ids(tbl,db);
	ids.each val,f
		if row[f] && row[f]!==val
			tbl.tbl_referred_by(db).each ft
				"update $(ft.table) set $(ft.f)=:newval where $(ft.f)=:oldval".lite_exec(db,{newval: row[f], oldval: val})
	cols=tbl.tbl_cols(db)
	if !cols => return "Table $tbl not found".fox_error()
	fld=[]
	cols.each ,k,idx
		if !row[k] => continue
		fld[]="$k=:$k"
	v1=[]
	ids.each v2,k2,idx2
		v1[]="$k2=:_old_$k2"
		row["_old_$k2"]=v2
	return "update $tbl set $(fld.map_join(', ')) where $(v1.map_join(' and '))".lite_exec(db,row)
}
int row_insert(map* row,char* tbl,char* db){
	cols=tbl.tbl_cols(db)
	if !cols => return "Table $tbl not found".fox_error().to_int()
	fld=[]
	cols.each ,k,idx
		if !row[k] => continue
		fld[]=k
	"insert into $tbl ('$(fld.map_join(\"', '\"))') values (:$(fld.map_join(', :')))".lite_exec(db,row)
	return "select last_insert_rowid()".sql_value(db).to_int()
}
map* toks_sql_params(map* toks, map* ret={}){
	toks.each val
		if val.is_map() => val.toks_sql_params(ret); continue
		if val.fox_at(0)==':' => ret[val.sub_str(1)]=val.sub_str(1)
	return ret
}
char* data1_str(void* in){
	ret=''
	if in.is_vec()
		ret.="["
		in.each val, ,idx
			ret.=val.data1_str()
			if idx<in.map_len() => ret.=", "
		ret.="]"
		return ret
	if in.is_map()
		ret.="{"
		in.each val, key, idx
			ret.=key.data1_str()
			if val => ret.=" "
			ret.=val.data1_str()
			if idx<in.map_len() => ret.=", "
		ret.="}"
		return ret
	if in.is_str()
		if in.str_chrs(" \t\n\r") => return in.str_quote()
	return in
}
char* data_str(map* in, int level=0){
	ret=''
	in.each val, key
		if val.is_map()
			if val.name===key && val.type
				ret.="\t".str_times(level)..key.." - "..val.type
				val.each v, k
					if k.is_word("name type") => continue
					ret.=", "..k.." "..v.data1_str()
				ret.="\n"
			else
				ret.="\t".str_times(level)..key.."\n"..val.data_str(level+1).."\n"
			continue
		ret.="\t".str_times(level)..key.." "..val.."\n"
	return ret
}
//char* callback_php(map* param,char* name) => return param.call_php(name)
char* fkey_show(char* sql,char* db,char* id){
	sign="$sql/$id"
	ret=''
	if (ret=sign.cache(:str_show)) => return ret
	return sign.cache(:str_show,sql.fkey_sql(db).sql_add_where({id: ':id'}).sql_row(db,{id: id}).name)
}
int fkey_valid(char* sql,char* db,char* id){
	return sql.fkey_show(db,id) ? 1 : 0
}

// habib -- schema
map* lite_schema(char* db){
	if !db => return NULL
	if _globals.dbs[db].schema => return _globals.dbs[db].schema
	if _globals.dbs[db].is_str() => _globals.dbs[db]=_globals.dbs[db].parse_connection()
	ret=db.db_tables()	
	_globals.dbs[db].schema=ret
	return ret
}
map* sql_order(char* sql){
	mp=sql.sql_map()
	ret={}
	mp[mp->len-1].order.each val,,idx
		mp1=val
		col=mp1[0].sql_str()
		ord=mp1[1].sql_str()
		int iord=1
		if ord===:desc => iord=-1
		ret[col]=iord
	
	return ret
}
map* crosstab_cols(map* cols,char* sql,char* db,map* params){
	mp=sql.sql_map()
	if !mp.crosstab => return NULL
	col1=cols[0].alias
	col2_name=cols[cols->len-2].alias
	col2_expr=cols[cols->len-2].expr.map_join()
	sum=cols[cols->len-1]
	table=cols[sum].table
	order={(col2_expr): mp.order[col2_expr]}
	sql="select distinct "..col2_expr.." as val"..mp.from.re_from()..mp.where.re_where()..order.re_order()
	rows=sql.sql_pairs(db)
	ret={}
	fsum=sum.sum
	if fsum==="*" => fsum="1"
	rows.each  val,,i
		f=''
		if mp.prefix
			f=mp.prefix.."_"..val.str_code()
		else
			f=val.str_code()
		if params => params[f]=val
		ret[f]={type: :amount, label: val.to_str(), alias: f, expr: "sum(if($(col2_expr)=:$f,$fsum,0))".sql_toks(), db: db, table: table,aggregate: sum.aggregate}
	return ret
}
map* sql_select_cols(char* sql,char* db=NULL,map* params=NULL){
	ret={}
	if sql.is_code()
		ret=sql.tbl_cols(db).map_dup()
		ret.each v6 ,k6,i6=> v6.expr=[k6]
		return ret
	cols=sql.sql_cls(:select)
	if !db
		tbl=sql.sql_table()
		cols.each v,k,idx
			ret[k]={alias: k, expr: v, table: tbl}
		return ret
	cols.each v,k,idx
		if k==="*"
			sql.sql_tables(db).each ssql, talias
				ssql.sql_select_cols(db).each col, f
					if ret[f] => continue
					ret[f]=col.map_dup()
					ret[f].expr=talias.is_code() ? [talias,".",f] : [f]
					ret[f].alias=f
					ret[f].talias=talias
		else if k.str_end(".*")
			talias=k.sub_str(0,-2)
			tcols=sql.sql_select_cols(db)[talias]
			if !tcols => "Invalid table alias $k in sql $sql".fox_error()
			tcols.each v2,k2,idx2
				if cols[k2]||ret[k2] => continue
				ret[k2]=v2.map_dup()
				ret[k2].expr=talias.is_code() ? [talias,".",k2] : [k2]
				ret[k2].alias=k2
				ret[k2].talias=talias
		else
			ret[k]=sql.sql_col(db,v)
			ret[k].expr=v
			ret[k].alias=k
	ccols=ret.crosstab_cols(sql,db,params)	
	if ccols
		sum=ret[ret->len-1]
		ret.map_del(ret->len-1).map_compact()
		ret.map_merge(ccols)
		ret[sum.alias]=sum
	return ret
}
char* sql_add_where(char* sql,map* mp){
	return sql.sql_map().add(:where,sql.sql_cls(:where).map_merge(mp)).map_sql()
}
map* sql_where_cols(char* sql,char* db){
	ret={}
	sql.sql_cls(:where).each val,k
		if !k.is_str() => continue
		ret[k]=sql.sql_col(db,k.sql_toks())
	sql.sql_cls(:having).each val,k
		if !k.is_str() => continue
		ret[k]=sql.sql_col(db,k.sql_toks())
	return ret
}
map* sql_where_vals(char* sql){
	ret={}
	sql.sql_cls(:where).each val,k
		if !k.is_str() => continue
		sval=val.sql_str(val[0])
		if "\"'".strchr(sval[0]) => sval=sval.str_unquote()
		ret[k]=sval
	sql.sql_cls(:having).each val,k
		if !k.is_str() => continue
		sval=val.sql_str(val[0])
		if "\"'".strchr(sval[0]) => sval=sval.str_unquote()
		ret[k]=sval.sql_str()
	return ret
}
//char* sql_col_alias(char* sql,char* db,char* name){
//	toks=name.sql_toks()
//	if toks.map_len()==3 && toks[1]==="." => return name
//	tbls=sql.sql_tables(db)
//	if tbls.map_len()>1 && name.is_code()
//
//}
char* sql_add_limit(char* sql,int rpp=200,int page=0){
	return sql.sql_add_cls(:limit,{limit: rpp, offset: rpp*page})
}
char* sql_add_order(char* sql,char* db,map* order=NULL){
	order=sql.sql_cls(:order).map_merge(order)
	if !order => order={}
	sql.sql_pkeys(db).each f
		if !order[f] => order[f]=1
	return sql.sql_add_cls(:order,order)
}
char* sql_add_filter(char* sql,map* filter){
	dsql=sql.sql_map()
	filter.each val,k
		dsql.where[k]=":"..k
	return dsql.map_sql()
}
char* sql_str(void* data){
	if !data => return NULL
	int type=data.ptr_type()
	if type==String => return data
	if type==Map||type==Vector
		mp=(map*)data
		ret=''
		mp.each ,,idx
			if ret && mp[idx].is_map() && mp[idx-1].is_map() => ret.=", "
			else if ret && !mp[idx].str_is_oper() && !mp[idx-1].str_is_oper() => ret.=" "
			ret.=mp[idx].sql_str()
		return ret
	return int_str((long)data)
}
char* re_select(map* mp){
	int i=0
	if !mp.select => return NULL
	ret="select "
	if mp.unique => ret.="distinct "
	if mp.crosstab => ret.="crosstab "
		if mp.prefix => ret.="prefix "..mp.prefix
	mp.select.each v,k,idx
		if i++ => ret.=", "
		v2=v.sql_str()
		if v2.str_end(".*") && mp.select.map_len()==1 => v2="*"
		ret.=v2
		if k!==v2 && k.is_code() => ret.=" as "..k.is_str()
	
	return ret
}
char* re_from(map* cls){
	int i=0
	if !cls => return NULL
	ret=" from "
	cls.each v,k,idx
		map* mp1=v
		if mp1.join_type => ret.=" "..mp1.join_type.sql_str()
		if i++ => ret.=" join "
		if mp1.tbl.is_code() => ret.=mp1.tbl
		else ret.="("..mp1.tbl..")"
		if mp1.tbl!==k => ret.=" as "..k.is_str()
		if mp1.on
			ret.=" on "..mp1.on.sql_str()
	return ret
}
char* re_where(map* cls){
	int i=0
	if !cls => return NULL
	ret=" where "
	cls.each v,k,idx
		if i++ => ret.=" and "
		if k.is_str()
			if k.is_code()
				ret.="\""..k.."\"="
			else
				ret.=k.."="
		ret.=v.sql_str()
	return ret
}
char* re_group(map* cls){
	int i=0
	if !cls => return NULL
	ret=" group by "
	cls.each v,,idx
		if i++ => ret.=", "
		ret.=v.sql_str()
	
	return ret
}
char* re_having(map* cls){
	int i=0
	if !cls => return NULL
	ret=" having "
	cls.each v,k,idx
		if i++ => ret.=", "
		if k.is_str() => ret.=k.."="
		ret.=v.sql_str()
	
	return ret
}
char* re_order(map* cls){
	int i=0
	if !cls => return NULL
	ret=" order by "
	cls.each v,k,idx
		if i++ => ret.=", "
		ret.=k
		if v.is_int()<0 => ret.=" desc"
	return ret
}
char* re_union(map* cls){
	if !cls => return NULL
	return " union "..cls.map_join(" ")
}
char* re_limit(map* cls){
	if !cls => return NULL
	return " limit "..str_join(cls.offset.is_int() ? cls.offset.to_str() : '',", ",cls.limit.to_str())
}
char* map_sql(map* mp){
	if !mp => return NULL
	return re_select(mp)..re_from(mp.from)..re_where(mp.where)..re_group(mp.group)..re_having(mp.having)..re_order(mp.order)..re_limit(mp.limit)..re_union(mp.union)
}
int has_aggregate(char* sql){
	sql.sql_select_cols().cols.each col,,i => if col.aggregate => return 1
	return 0
}
char* sql_auto_join(char* sql,char* db=NULL){
	dsql=sql.sql_map()
	cols={}
	ok=1
	dsql.from.each op2 ,tbl2,i2=> if i2 && !op2.on => ok=0; break;
	if ok => return sql
	dsql.from.each op,tbl,i
		if i && !op.on
			cols.each op2,t2,i2
				op2.each op3,f3,i3
					if !op3.sql => continue
					sql2=op3.sql.fkey_sql(db)
					if sql2.sql_table()!==op.tbl => continue
					tblfld=sql2.sql_select_cols(db)[0].expr.toks_split(".",2)
					ff=tblfld.map_len()==2 ? tblfld[1] : tblfld[0]	
					op.on=[t2,".",f3].vec_merge(["=",tbl,".",ff])
					break
				if op.on => break
			if !op.on => "auto join failed".fox_error()
		cols[tbl]=op.tbl.sql_select_cols(db)
	return dsql.map_sql()
}
char* sql_auto_group(char* sql,char* db=NULL){
	dsql=sql.sql_map()
	if dsql.group => return sql
	cols=sql.sql_select_cols(db)
	agg=0
	noagg=0
	cols.each col,,i
		if col.aggregate => agg++
		else noagg++
	if !agg || !noagg => return sql
	dsql.group=[]
	cols.each col2 ,f2,i2=> if !col2.aggregate => dsql.group[]=f2
	return dsql.map_sql()
}
char* sql_add_cls(char* sql,char* cls,map* vals){
	dsql=sql.sql_map()
	dsql[cls]=vals
	return dsql.map_sql()
}
map* sql_cls(char* sql,char* cls) => return sql.sql_map()[cls]
map* sql_tables(char* sql,char* db){
	if sql.is_code() => return {(sql): sql}
	ret={}
	sql.sql_cls(:from).each v,k,idx
		ret[k.is_code() ? k : NULL]=v.tbl
	return ret
}
map* sql_col(char* sql,char* db,map* exp){
	ret={}
	if exp->len==1
		char* name=exp[0]
		sql.sql_tables(db).each ssql
			cols=ssql.sql_select_cols(db)
			if cols[name] => return cols[name]
		ret=sql.sql_cls(:select)[name]
		if ret && ret.sql_str()!==name => return sql.sql_col(db,ret)
		"Field $name not found in query.".fox_error()
	if exp->len==3 && exp[1].is_str()==="."
		ret=sql.sql_tables(db)[exp[0]].sql_select_cols(db)[exp[2]]
		if !ret => "Field $(exp.sql_str()) not found in $sql".fox_error()
		return ret
	if exp->len>1
		if exp.map_has_word("|")
			ret.type=:text
			return ret
	name=exp.is_func(1)
	if name
		if name.is_word("sum count avg")
			ret.aggregate=name
			ret.sum=exp.sql_func_params(1)[0].sql_str()
			ret.type=:amount
			return ret
		if name.is_word("month quarter year date time")
			ret.exp=exp.sql_str()
			ret.type=name
			return ret
		if name===:sub_str
			ret.type=:text
			return ret
		if name===:floor
			ret.type=:number
			return ret
		if name===:empty
			ret.type=:bool
			return ret
		if name===:if
			return sql.sql_col(db,exp.sql_func_params(1)[1])
	name=exp[0].is_str()
	if *name=='"'||*name=='\''
		ret.type=:text
		return ret
	"can't find $(exp.sql_str()) in $sql".fox_error()
	return NULL
}
char* sql_table(char* sql){
	if sql.is_code() => return sql
	return sql.sql_cls(:from)[0].tbl.sql_table()
}
map* sql_pkeys(char* sql,char* db) => return sql.sql_table().tbl_pkeys(db)
map* to_cols(void* cols,char* sql=NULL,char* db=NULL){
	if cols.is_str() => cols=cols.xkeys()
	if !sql
		cols.each col,f
			if !col
				cols[f]={type: f.name_type()}
			else if col.is_str()
				cols[f]={type: col}
			else if !col.type
				cols[f].type=f.name_type()
		return cols
	ret={}
	cols.each col,f,idx
		ret[f]=sql.sql_col(db,f.sql_toks())
		if col.is_map() => ret[f].map_merge(col)
		if ret[f].type==="-" => ret[f].type=cols[f].type
	return ret
}
map* sql_cols(char* sql,char* db,void* cols=NULL){
	if !cols => return sql.sql_select_cols(db)
	return cols.to_cols(sql,db)
}
map* sql_add_cols(char* sql,char* db,map* cols=NULL){
	scols=sql.sql_table().tbl_cols(db)
	if cols.map_len() => return scols.cols_collect(cols)
	ret={}
	scols.each op,f
		if op.noshow => continue
		if op.noadd => continue
		if op.auto => continue
		if op.calc => continue
		if op.type===:guid && !op.sql => continue
		ret[f]=op
	return ret
}
map* sql_view_cols(char* sql,char* db,map* cols=NULL){
	scols=sql.sql_table().tbl_cols(db)
	if cols.map_len() => return scols.cols_collect(cols)
	ret={}
	scols.each op,f
		if op.noshow => continue
		if op.type===:guid && !op.sql => continue
		ret[f]=op
	return ret
}
map* sql_edit_cols(char* sql,char* db,map* cols=NULL){
	scols=sql.sql_table().tbl_cols(db)
	if cols.map_len() => return scols.cols_collect(cols)
	ret={}
	scols.each op,f
		if op.noshow => continue
		if op.noedit => continue
		if op.auto => continue
		if op.calc => continue
		if op.type===:guid && !op.sql => continue
		ret[f]=op
	return ret
}
map* sql_list_cols(char* sql,char* db,map* cols=NULL){
	scols=sql.sql_select_cols(db)
	if cols.map_len() => return scols.cols_collect(cols)
	ret={}
	scols.each op,f
		if op.noshow => continue
		if op.nolist => continue
		if op.type===:guid && !op.sql => continue
		if op.type===:password => continue
		ret[f]=op
	return ret
}
char* sql_lite(char* sql,char* db=NULL,map* params=NULL){
	sql=sql.sql_add_order(db).sql_auto_join(db).sql_auto_group(db)
	ret=sql.sql_map()
	if db
		ret.select={}
		sql.sql_select_cols(db,params).each prop,name,idx
			ret.select[name]=prop.expr
		ret.crosstab=NULL
		ret.prefix=NULL
	return ret.search_sql_func(:lite).map_sql()..";"
}
int sql_utest(char* in,char* out){
	if !out => out=in
	mp=in.sql_map()
	ret=mp.search_sql_func(:lite).map_sql()
	return ret.utest(out,in)
}
map* sql_missing_params(char* sql, map* params){
	ret={}
	sql.sql_params().each ,key
		if !params[key] => ret[key]=key
	return ret.is_null()
}
map* fkey_list(char* sql,char* db,map* params=NULL){
	if sql.sql_missing_params(params) => return NULL
	return sql.fkey_sql(db).sql_pairs(db,params)
}
char* fkey_sql(char* sql,char* db){
	cols=sql.sql_select_cols(db)
	pkey=cols.cols_pkeys(db)[0]
	skey=cols.cols_skeys(db)[0]
	ret=sql.sql_map(db)
	ret.select={id: cols[pkey].expr, name: cols[skey].expr}
	return ret.map_sql().sql_add_order(db)
}
map* sql_params(char* sql){
	return sql.sql_toks().toks_sql_params()
}
void* id_delete(void* ids,char* tbl,char* db){
	ids=ids.id_param(tbl,db)
	return ("delete from $tbl"..re_where(ids.where_param())).lite_exec(db,ids)
}
char* read_textblock(map* lines, int* lineno,char* terminator,char** outline){
	terminator=terminator.str_trim()
	int indent=lines[*lineno+1].str_level()
	ret=''
	lines.each line,,no=*lineno+1
		*lineno=no
		if line.str_level()<indent || (line+indent).str_start(terminator)
			*outline=line+terminator.str_len()+indent
			return terminator..ret..terminator
		else ret.=line.sub_str(indent).."\n"
	*outline=''
	return ret
}
map* sql_tokenizer(char** line){
	str=*line
	map* mp=[]
	if !*str => return NULL
	char term=closing_paren(*str)
	if term => str++
	while *str && *str!=term
		if "\"'`".strchr(*str) => mp[]=read_quote(&str)
		else if str.str_start("--") => read_theline(&str);
		else if str.str_start("/*") => read_upto(&str,"*/");
		else if *str==':' => mp[]=fox_read_symbol(&str)
		else if is_oper(*str) => mp[]=fox_read_oper(&str,term)
		else if *str>='0' && *str<='9' => mp[]=read_num(&str)
		else if is_alpha(*str) => mp[]=read_alpha(&str)
		else if "([{".strchr(*str) => mp.read_paren(&str,sql_tokenizer)
		else if " \t".strchr(*str) => read_space(&str);
		else if "\n\r".strchr(*str) => read_newline(&str);
		else if ".,;".strchr(*str) => mp[]=str.sub_str(0,1)
		str++
	
	*line=str
	return mp
}
map* prop_tokenizer(char** line){
	str=*line
	map* mp=[]
	if !*str => return NULL
	char term=closing_paren(*str)
	if term => str++
	while *str && *str!=term
		if "\"'`".strchr(*str) => mp[]=read_quote(&str)
		else if str.str_start("--") => read_theline(&str);
		else if str.str_start("/*") => read_upto(&str,"*/");
		else if *str==':' => mp[]=fox_read_symbol(&str)
		else if is_oper(*str) => mp[]=fox_read_oper(&str,term)
		else if *str>='0' && *str<='9' => mp[]=read_num(&str)
		else if is_alpha(*str) => mp[]=read_alpha(&str)
		else if "([{".strchr(*str) => mp.read_paren(&str,sql_tokenizer)
		else if " \t".strchr(*str) => read_space(&str);
		else if "\n\r".strchr(*str) => read_newline(&str);
		else if ".,;".strchr(*str) => mp[]=str.sub_str(0,1)
		str++
	
	*line=str
	return mp
}
map* tokenizer(char** line,char* comment){
	str=*line
	mp=[]
	if !*str => return mp
	term=*str
	if term=='(' => term=')'
	else if term=='[' => term=']'
	else if term=='{' => term='}'
	else term=0
	if term => str++
	while *str && *str!=term
		if "\"'`".strchr(*str) => mp[]=read_quote(&str)
		else if str.str_start("--") => read_theline(&str)
		else if str.str_start("#") => mp[]=read_theline(&str)
		else if str.str_start("/*") => read_upto_word(&str,"*/")
		else if *str==':' => mp[]=fox_read_symbol(&str)
		else if is_oper(*str) => mp[]=fox_read_oper(&str,term)
		else if (*str=='.' && (str[1]>='0' && str[1]<='9'))|| (*str>='0' && *str<='9') => mp[]=read_num(&str)
		else if is_alpha(*str) => mp[]=read_alpha(&str)
		else if "([{".strchr(*str)
			char temp[2]={0}
			temp[0]=*str
			signs="([{)]}"
			int hit=signs-signs.strchr(*str)
			mp[]=temp
			mp[]=tokenizer(&str,comment)
			temp[0]=signs[hit+3]
			mp[]=temp
		
		else if " \t".strchr(*str) => read_space(&str)
		else if "\n\r".strchr(*str) => read_newline(&str)
		else if ".,;".strchr(*str) => mp[]=str.sub_str(0,1)
		str++
		
	*line=str
	return mp
}
char* to_sql(char* sql){
	return sql.sql_map().map_sql()
}
map* schema_fkeys(char* db){
	ret=_globals.schema.fkeys[db]
	if !ret
		ret=[]
		_globals.schema.db.each tbl,name
			tbl.cols.each col,f
				if col.sql
					sql=col.sql.fkey_sql(db)
					ret[]={table: name, f: f, table2: sql.sql_table(), f2: sql.sql_cols(db)[0].name, db: col.db}
		_globals.schema.fkeys[db]=ret
	return ret
}
map* tbl_referred_by(char* tbl,char* db){
	ret=[]
	db.schema_fkeys().each rel
		if rel.table2===tbl
			ret[]={table: rel.table, f: rel.f, f2: rel.f2}
	return ret
}
map* sql_sums(char* sql,char* db,map* cols,map* params){
	sum={}
	cols.each col,f
		if !{{
			text 0
			amount 1
		}}.map_type(col.type).to_int() => continue
		expr=col.expr.sql_str()
		if !col.aggregate && !expr.str_start("sum(") && !expr.str_start("count(") => expr="sum($expr)"
		sum[f]=expr.sql_toks()
	if !sum.map_len() => return NULL
	dsql=sql.sql_map()
	dsql.select=sum
	dsql.order=NULL
	dsql.limit=NULL
	dsql.group=NULL
	return dsql.map_sql().sql_row(db,params)
}
int sql_count(char* sql,char* db,map* params=NULL){
	sqls=sql.sql_map(db)
	expr="*";
	if sqls.aggregate
		if sqls.having => return "select count(*) from ($sql)".sql_value(db,params).to_int()
		sql.sql_cols(db).each val,key
			if !val.aggregate => expr="distinct $key"; break
	return ("select count($expr) "..sqls.from.re_from()..sqls.where.re_where()).sql_value(db,params).to_int()
}
map* sql_query(char* sql,char* db,map* where=NULL) => return sql.sql_add_where(where).sql_rows(db,where)
char* join_clause(char* pre,map* mp,char* clause,char* by,char* sub1,char* sub2,char* use_cls){
	mp1=mp
	if clause => mp1=mp[clause]
	ret=''
	mp1.each ,,idx2
		ret2=''
		if !sub1 => ret2=mp1[idx2].to_str()
		if !sub2 => ret2=mp1[idx2].sql_map_join(sub1)
		else
			mp2=mp1[idx2]
			ret3=''
			mp1[idx2].each v4,k4,idx4
				if is_str(k4) => ret3=ret3.str_join(sub1,mp2.map_key_val(idx4).sql_map_join(sub2))
			
			ret2=ret3
		ret=ret.str_join(by,ret2)
	
	if use_cls && ret => ret=use_cls.." "..ret
	return pre.str_join(" ",ret)
}
map* de_select(map* cls){
	ret={}
	if cls.select[0]===:distinct || cls.select[0]===:unique
		cls.unique=1
		cls.select.vec_del(0).vec_compact()
	if cls.select[0]===:crosstab
		cls.crosstab=1
		cls.select.vec_del(0).vec_compact()
		if cls.select[0]===:prefix
			cls.prefix=cls.select[1]
			cls.select.vec_del(0,2).vec_compact()
	cls.select.map_split(",",0).each val,,idx
		mp1=val.map_split(:as,2)
		name=mp1->len==2 ? mp1[1].sql_str() : mp1[0].sql_str()
		ret[name]=mp1[0]
	return cls.select=ret
}
map* de_from(map* cls){
	ret={}
	last_join_type=NULL
	cls.from.map_split(:join,0).each v,,idx
		join_type=NULL
		map* words=v
		words.each v1,,idx1
			if v1.is_word("full inner left right cross outer")
				join_type=words.vec_slice(idx1,words->len)
				words.vec_compact()
				break
		parts=words.split_keywords("as on")
		parts.change_key(0,:tbl)
		if parts.tbl[0]==="(" => parts.tbl=parts.tbl.vec_del(0).vec_del(-1).vec_compact()[0].sql_toks_map().map_sql()
		else parts.tbl=parts.tbl.map_join()
		if parts.as => parts.as=parts.as.sql_str()
		else parts.as=parts.tbl
		if last_join_type => parts.join_type=last_join_type
		ret[parts.as]=parts
		last_join_type=join_type
	cls.from=ret
	return cls
}
map* parse_where(map* cls){
	if cls.map_has_word(:or) => return {NULL: cls}
	wheres={}
	cls.map_split(:and,0).each val2,,idx2
		eqs=val2.map_split("=",2);	
		void* val=eqs[0]
		key=''
		assert(eqs->len<=2) //to fix support explode(...,limit=2)
		if eqs->len==2
			key=val.sql_str()
			val=eqs[1]
		wheres[key]=val
	return wheres
}
map* de_where(map* cls){
	mp=cls.where
	if !mp => return cls
	return cls.where=mp.parse_where()
}
map* de_having(map* cls){
	mp=cls.having
	if !mp => return cls
	return cls.having=mp.parse_where()
}
map* de_order(map* cls){
	mp=cls.order
	if !mp => return cls
	if mp[0]===:by => mp.vec_del(1-1,1).vec_compact()
	ret={}
	mp.map_split(",",0).each val,,idx
		mp1=val
		col=mp1[0].sql_str()
		ord=mp1[1].sql_str()
		int iord=1
		if ord===:desc => iord=-1
		ret[col]=iord
	
	cls.order=ret
	return cls
}
map* de_group(map* cls){
	mp=cls.group
	if !mp => return cls
	if mp[0]===:by => mp.vec_del(1-1,1).vec_compact()
	cls.group=mp.map_split(",")
	return cls
}
map* de_limit(map* cls){
	mp=cls.limit
	if !mp => return cls
	mp=mp.map_split(",",2)
	int offset=mp[0].sql_str().stoi()
	int limit=mp[1].sql_str().stoi()
	if offset && !limit => limit=offset; offset=0
	cls.limit={offset: offset,limit: limit}
	return cls
}
map* sql_toks_map(map* toks){
	toks=toks.map_split(:union,2)
	ret=toks[0].split_keywords("select from where group having order limit")
		.de_from()
		.de_select()
		.de_where()
		.de_group()
		.de_having()
		.de_order()
		.de_limit()
	if toks[1] => ret.union=toks[1]
	return ret
}
map* sql_map(char* sql){
	if !sql => return NULL
	ret=sql.cache(:sql_map)
	if ret => return ret
	if !sql.str_has(" ") => sql="select * from $sql"
	return sql.sql_toks().sql_toks_map()
}
char* sql_map_join(map* mp,char* joiner){
	ret=''
	mp.each ,,idx => ret=ret.str_join(joiner,mp[idx].sql_str())
	return ret;	
}
char* var_join(void* v,char* joiner){
	if v.ptr_type()==String => return v
	if v.ptr_type()==Map||v.ptr_type()==Vector => return v.sql_map_join(joiner)
	return int_str((long)v)
}
map* sql_convert_func(map* mp,char* db){
	char* name=mp[0]
	params=[]
	mp.each ,,idx
		if idx==0 => continue
		params[]=mp[idx].sql_str()
	
	if db===:lite
		if name===:time => return "substr($(params[0]),12,8)".sql_toks()
		if name===:date => return "substr($(params[0]),1,10)".sql_toks()
		if name===:month => return "substr($(params[0]),1,7)".sql_toks()
		if name===:year => return "substr($(params[0]),1,4)".sql_toks()
		if name===:quarter => return "substr($(params[0]),1,5)||((substr($(params[0]),6,2)-1)/3+1)".sql_toks()
		if name===:empty => return "($(params[0]) is null or $(params[0])='')".sql_toks()
		if name===:if => return "case when $(params[0]) then $(params[1]) else $(params[2]) end".sql_toks()
	
	return NULL
}
char* is_func(map* mp,int idx){
	if !mp => return NULL
	if !mp[idx-1].is_code() => return NULL
	if mp[idx]!=="(" => return NULL
	return mp[idx-1]
}
map* sql_func_params(map* mp,int idx){
	return mp.is_func(idx) ? mp[idx+1].map_split(",",0) : NULL
}
map* get_func(map* mp,int idx){
	return mp.is_func(idx) ? [mp[idx-1]].vec_merge(mp[idx+1].map_split(",",0)) : NULL
}
map* search_sql_func(map* mp,char* db){
	if !mp => return NULL
	mp.each v,,idx
		if v.is_map() => mp[idx]=v.search_sql_func(db); continue
		mp1=mp.get_func(idx)
		if mp1 => mp1=mp1.sql_convert_func(db)
		if mp1 => mp.vec_splice(idx-1,4,mp1)
	return mp
}
void* key_var(char* key){
	if !key => return NULL
	if (long)key<0 => return int_var(-(long)key)
	return key
}
map* map_key_val(map* mp,int idx){//0
	assert(idx>=0 && idx<mp->len)
	return [mp->pairs[idx].id.key_var(),mp[idx]]
}
map* db_table_names(char* db){
	if _globals.schema._tbls
		return _globals.schema._tbls
	_globals.schema._tbls="select name from sqlite_master where type='table' and name not in ('sqlite_sequence', '_syncing', 'search', 'search_data', 'search_idx', 'search_content', 'search_docsize', 'search_config') order by 1".sql_pairs(db)
	return _globals.schema._tbls
}
map* cols_pkeys(map* cols){
	ret={}
	cols.each v,k,i
		if v.pkey => ret[k]=k
	if !ret.map_len() => ret[cols.map_key(0)]=cols.map_key(0)
	return ret
}
map* where_param(map* where){
	ret={}
	where.each ,key => ret[key]=":"..key
	return ret
}
void* is_null(void* val){
	if !val => return NULL
	if val.is_map() => return val.map_len() ? val : NULL
	if val.is_str() => return val.str_len() ? val : NULL
	if val.is_i() => return val.is_int() ? val : NULL
	return val
}
map* db_table(char* db,char* tbl){
	return db.db_cols(tbl).cols_table(tbl,db)
}
map* db_tables(char* db){
	ret={}
	db.db_table_names().each v,,i
		ret[v]=db.db_table(v)
	return ret
}
map* where_rows(map* where, char* tbl, char* db) => return tbl.sql_add_where(where.where_param()).sql_rows(db,where)
map* where_row(map* where, char* tbl, char* db) => return tbl.sql_add_where(where.where_param()).sql_row(db,where)
map* id_row(void* ids,char* tbl,char* db) => return ids.id_param(tbl,db).where_row(tbl, db)
map* id_param(void* ids, char* tbl, char* db){
	ids=ids.id_ids(tbl,db)
	ret={}
	tbl.tbl_pkeys(db).each val,key,idx
		ret[key]=ids.is_vec() ? ids[idx] : ids[key]
	return ret
}
map* id_ids(void* id,char* tbl,char* db){
	pkeys=tbl.tbl_pkeys(db)
	ret={}
	if id.is_i() => id=id.to_str()
	if id.is_str() => id=id.str_split("\t")
	assert(id.is_map())
	if pkeys->len!=id.map_len() => "PKey=$pkeys and id=$id, number of field mismatched".fox_error()
	if id.is_vec()
		pkeys.each f,,idx
			ret[f]=id[idx]
		return ret
	pkeys.each f
		ret[f]=id[f]
	return ret
}
map* db_cols(char* db,char* tbl){
	rs="pragma table_info ($tbl)".lite_exec(db,NULL)
	ret={}
	rs.each v,,idx
		col={}
		map* mp=v
		name=mp.name.str_lower()
		col.name=name
		func=mp.type.sql_toks().get_func(1)
		if !func
			col.type=mp.type.schema_type(0)
		else
			int size=func[1][0].stoi()
			col.size=size
			col.type=func[0].schema_type(size)
		
		if mp.pk.stoi() => col.pkey=int_var(1)
		if !mp.notnull.stoi() && !col.pkey => col.isnull=int_var(1)
		col.db=db
		col.table=tbl
		ret[name]=col
	return ret
}
map* tbl_pkeys(char* tbl,char* db) => return tbl.tbl_cols(db).cols_pkeys()
map* tbl_skeys(char* tbl,char* db) => return tbl.tbl_cols(db).cols_skeys()
map* cols_skeys(map* cols){
	if !cols.map_len() => return NULL
	cols.each ,name => if name.str_has(:name) => return {name: name}	
	return {(cols.map_key(0)): cols.map_key(0)}
}
map* sql_toks(char* line) => return sql_tokenizer(&line)
map* split_keywords(map* mp,char* words){
	if !mp => return mp
	ret={}
	curr=[]
	lastword=''
	mp.each ,,i
		if mp[i].is_word(words)
			if curr->len => ret[lastword]=curr
			lastword=mp[i]
			curr=[]
			continue
		curr[]=mp[i]
	if curr->len => ret[lastword]=curr
	return ret
}
char* lite_create_col(map* col){
	size=col.size.to_int()
	if !size => size=col.type.type_size()
	type={{
		text varchar
		para clob
		file blob
		int number
		float float
		date date
		time time
		datetime datetime
		daymonth varchar
		month varchar
	}}.map_type(col.type)
	if !type => "col.type=$(col.type) not matched".fox_error()
	name=col.name
	if type===:varchar => return "$name varchar($size) collate nocase not null default ''"
	if type===:number => return "$name integer not null default 0"
	if type===:float => return "$name real not null default 0"
	if type===:clob => return "$name clob not null default ''"
	if type===:blob => return "$name blob not null default ''"
	if type===:date => return "$name date not null default ''"
	if type===:time => return "$name time not null default ''"
	if type===:datetime => return "$name datetime not null default ''"
	if type===:yearmonth => return "$name varchar(7) not null default ''"
	"litecreate() type $type not supported".fox_error()
	return NULL
}
int is_indexed(char* type){
	return {{
		text 0
		code 1
		password 0
		email 0
	}}.map_type(type).to_int()
}
map* tbl_trigger_sqls(map* tbl){
	if tbl.cols.lft => return tbl.name.lite_trigger_tree(tbl.cols.cols_pkeys().map_key(0))
	if tbl.cols.slno => return tbl.name.lite_trigger_slno(tbl.cols.cols_pkeys().map_key(0),tbl.cols.cols_pkeys().map_key(1))
	return []
}
map* create_index_sqls(map* tbl){
	ret=[]
	tbl.cols.each f,k,i
		if !f.type.is_indexed() => continue
		ret[]="create index idx_$(tbl.name)_$(f.name) on $(tbl.name)($(f.name))"
	return ret
}
char* drop_sql(char* name) => return "drop table if exists $name"
char* create_sql(map* tbl,char* name=NULL){
	if !name => name=tbl.name
	cls={}
	tbl.cols.each v ,k,i=> cls[k]=v.lite_create_col()
	pkeys=tbl.cols.cols_pkeys()
	if pkeys.map_len()==1 && tbl.cols[pkeys[0]].type.is_word("int integer")
		cls[pkeys[0]]="$(pkeys[0]) integer primary key autoincrement"
	else
		cls[]="primary key ($(pkeys.map_join(\",\")))"
	return "create table $name ($(cls.map_join(\",\")))"
}
char* schema_type(char* type,int size){
	if size==36 => return :guid
	if size==1 && type.is_word("int tinyint") => return :bool
	if type===:clob => return :para
	if type.is_word("mediumblob longblob") => return :blob
	if type.is_word("string varchar2 varchar char")
		if size>=200 => return :para
		if size>=128 => return :text
	
	if type.is_word("varchar2 varchar char") => return :code
	if type.is_word("number integer") => return :int
	if type===:real => return :float
	if type===:timestamp => return :datetime
	if type===:integer => return :int
//"%s=%s".dx(type,type.is_word("varchar2 varchar"))
//type.dxx()
	return type
}
int has_table(char* db,char* tbl){
	return "select count(*) from sqlite_master where type='table' and name=:name".sql_value(db,{name: tbl}).to_int()
}
map* map_cols(void* cols,char* tbl,char* db){
	cols.each f,name,i
		f.name=name
		f.table=tbl
		f.db=db
	return cols
}
map* cols_table(map* cols,char* tbl,char* db){
	if !cols => return NULL
	return {
		name: tbl,
		cols: cols.map_cols(tbl,db),
		db: db,
		item: tbl.str_title()
	}
}
map* cols_collect(map* cols,void* collect){
	assert(cols.is_map())
	if collect.is_str() => collect=collect.str_map()
	ret={}
	collect.each op,f
		if f==="*" => ret.map_merge(cols)
		else if f[0]=='-'
			ret.map_del_key(f.sub_str(1)).map_compact()
		else if f.str_has("-")
			limit=f.str_split("-",2)
			inlimit=0
			cols.each ,f1
				if limit[0]===f1
					inlimit=1
				if inlimit
					ret[f1]=cols[f1]
				if limit[1]===f1
					inlimit=0
		else
			ret[f]=cols[f]
			if ret[f].is_map()
				ret[f]=ret[f].map_dup()
				if op.is_map() => ret[f].map_merge(op)
				if ret[f].type==="-" => ret[f].type=cols[f].type
	return ret
}
char* name_type(char* name){
	types().each ,type
		if name.str_has(type) => return type
	"name=text,desc=para,title=text".str_map().each val,key
		if name.str_has(key) => return val
	return :text
}
void retree(char* db){
	rows=:section.sql_rows(db)
	"delete from section".sql_exec(db)
	rows.each row
		row.map_del_key(:lft)
		row.map_del_key(:rgt)
		row.row_insert(:section,db)
}
