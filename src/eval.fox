#include <fox.h>

char* callfunc_c(map* funcs){
	ret="function calls\n"
	fdups={}
	funcs.each v,k,i2
		if fdups[v.name] => continue
		fdups[v.name]=1
		if k===:args_map => continue
		if v.name.is_word("main run") => continue
		str_params=v.func_ccall()
		if(!str_params)
			continue
		//pp1
		ret.="\t\tcase %p: { %s break; }\n".mstr(v.name.str_hash(),str_params)
	return ret
}
char* write_c(char* infile,char* outfile=NULL){
	source_funcs()
	return infile.file_read().x_c().write_file(outfile,1)
}
char* func_ccall(map* fn){
	ret=''
	preproc=''
	isvariadic=0
	fn.params.each v,k,i
		char* def=v.default
		v=v.type
		v=v.drop_left(:const\ )
		v=v.drop_left(:unsigned\ )
		pre=''
		post=''
		mid="v.map_id($i)"
		if k==="..."
			mtype=''
			if fn.type===:void || fn.type.str_end("*") => mtype=:ptr
			else if fn.type===:int => mtype=:int
			else if fn.type===:double => mtype=:double
			else return NULL
			isvariadic=1
			ret="call_variadic_$mtype(v,$(fn.name),\"$(fn.name)\")"
			break
		else if v==="char*" => post=".is_str()"
		else if v==="char**" => preproc.="char* p$(k)_$(fn.name)=v.map_id($i).is_str(); "; mid="&p$(k)_$(fn.name)"
		else if v==="map*" => post=".is_map()"
		else if v.is_word("int long size_t time_t") || v==="long long" => post=".to_int()"
		else if v===:char
			post=".is_str() ? $mid.is_str()[0] : $mid.to_int())"
			pre="("
		else if v.is_word("double float") => post=".to_double()"
		else if !v.str_end("*")
			return NULL
		if def => ret.="v->len>=$i ? $pre$mid$post : $(def.x_c().sub_str(0,-1)),"
		else => ret.="$pre$mid$post,"
	char* postproc=''
	if fn.type.is_word("int long long size_t time_t char") => postproc=".int_var()"; preproc.='return '
	else if fn.type.is_word("double float") => postproc=".double_var()"; preproc.='return '
	else if fn.type===:void
		postproc.="; return NULL"
	else if(!fn.type.is_word("void* map* char*")) return NULL
	else preproc.='return '
	if isvariadic => return "$preproc$ret$postproc".x_c()
	return "$preproc$(fn.name)($(ret.sub_str(0,-1).null_str()))$postproc".x_c()
	//pp1
}
char* fox_c(char* infile, char* outfile=NULL) => return infile.file_read().x_c().write_file(outfile)
char* x_c(char* in) => return in.x_toks().toks_c()
map* type_convert(map* tok,char* outtype,map* env,map* fs,map* fn){
	if !outtype => return tok
	intype=tok.expr_type(0,0,env,fs)	
	if !intype => return tok
	if intype===outtype => return tok
	if intype.is_word("int double long long") && outtype.str_start(intype) && outtype[intype.str_len()]=='*' && !outtype[intype.str_len()+1]
		return tok.vec_splice(1,0,["&",NULL])
	if intype.is_word("int long long size_t")
		if outtype==="void*" => return tok.wrap_call(:int_var)
		else if outtype==="char*" => return tok.wrap_call(:int_str)
	else if intype==="void*"
		if outtype===:double => return tok.wrap_call(:to_double)
	else if intype===:double
		if outtype==="void*" => return tok.wrap_call(:double_var)
		else if outtype==="char*" => return tok.wrap_call(:double_str)
	else if intype==="map*"
		if outtype==="char*" => return tok.wrap_call(:to_str)
	else if intype==="char*"
		if outtype===:int => return tok.wrap_call(:stoi)
		else if outtype==="char**"
			return tok.vec_splice(1,0,["&",NULL])
	else if intype==="char**"
		if outtype==="char*" => return tok.vec_splice(1,0,["*",NULL])
	return tok
}
map* param_c(map* params,map* env,map* fs,map* fn){
	assert(fn)
	if !params => return NULL
	xparam=params.toks_split(",")
	cparam=[]
	sig=fn.params
	sig.each p,name,i
		if name==="..."
			for int idx=i; idx<xparam->len; idx++
				if xparam[idx][1]===:End => break
				cparam[]=xparam[idx].type_convert(p.type,env,fs,fn)
			if cparam[cparam.map_len()-1][1].neq(:End)
				if !cparam[cparam.map_len()-1][1] => cparam[cparam.map_len()-1][1]=:End
				else
					endmark=cparam.map_len() ? " End" : :End
					cparam[]=endmark.x_map()
			break
		else if xparam[i].map_len()<2
			if !p.default => break
			cparam[]=p.default.x_toks()[1].vec_del(-2,0).vec_compact() //x_map().colon_str().dot_key().str_dollars()
		else 
//			xparam[i].dx(:IN)
//			xparam[i].expr_type(0,0,env,fs).dx(:INTYPE)
//			p.type.dx(:OUT)
//			xparam[i].type_convert(p.type,env,fs,fn).toks_c().dx(:CONVERTED)
//			"^^^^^^^^^^^^".px()
			cparam[]=xparam[i].type_convert(p.type,env,fs,fn)
	ret=cparam.toks_join(",")
	return ret
}
char* head_type(map* toks, int idx, int upto, map* env,map* fs){
	head=toks.expr_head(idx)
	return toks.expr_type(head, upto, env, fs)
}
char* help() => return funcs().funcs_cdecl()
char* expr_type(map* toks,int idx=0,int upto=0,map* env={:_globals : "map*"},map* fs=NULL){
	void* v=toks[idx+1]
	if v.is_map() => return v.expr_type(0,upto,env,fs)
	w=v.is_str()
	if !w => return NULL
	assert(w.is_str() && w.str_len())
	if toks.next_tok(idx,"?",upto)
		return toks.expr_type(toks.next_tok(idx,"?")+1,upto,env,fs)
//	else if toks.next_tok(idx,"/",upto) => return :int
	else if toks[idx+3]==="("
		name=toks[idx+1].is_str()
		if fs[name] => return fs[name].type
		return funcs()[name].type
	else if w.is_word("++ --") => return toks.expr_type(idx+2,upto,env,fs)
	else if *w=='"' => return "char*"
	else if *w=='\'' && w[1]=='\'' => return "char*"
	else if *w=='\'' => return :char
	else if *w>='0' && *w<='9' || *w=='-' || *w=='+' => return w.strchr('.') ? :double : :int
	else if toks.is_typecast(idx) => return toks.is_typecast(idx)
	else if w==="(" => return toks[idx+3].expr_type(0,upto,env,fs)
	else if w==="*" => return toks.expr_type(idx+2,upto,env,fs).sub_str(0,-1)
	else if w==="&" => return toks.expr_type(idx+2,upto,env,fs).str_dup().."*"
	else if w===:NULL => return "void*"
	else if env[w]
		if toks.next_tok(idx,"-",upto) && toks.expr_type(toks.next_tok(idx,"-",upto)+1,upto,env,fs).is_word("char* void* map*")
			return :int
		char* ret=env[w]	
		if !upto => upto=toks->len
		map* structtype=NULL
		for int i=idx+3; i<upto; i+=2
			v=toks[i]
			if v.is_word(". ->")
				structtype=structs()[ret.str_trim("*")]
			else if structtype && v.is_code() && !toks.syn_is_call(i) && structtype[v]
				ret=structtype[v]
			else if v==="[" && ret.fox_at(-1)=='*'
				ret=ret.sub_str(0,-1)
				i+=4
			else if v==="-"
				if ret===:int => return ret
				rest=toks.expr_type(i+1,upto,env,fs)
				if rest.fox_at(-1)=='*' => return :int
				return ret
			else return ret
		return ret
	return NULL
}
map* x_toks(char* in,int is_script=0){
	if !in => return NULL
	return in.x_map()
		.colon_str()
		.dot_key()
		.str_dollars()
		.add_curly()
		.force_curly()
		.add_semicolon()
		.expand_main()
		.dot_func()
		.dot_each()
		.toks_syn()
		.heredoc_str()
		.string_operators()
		.inline_vectors()
		.auto_types(:c, is_script)
		.single_quotes()
}
map* auto_types(map* toks,char* context=:c,int is_script=0,map* env={},map* fns={},map* func=NULL,int idx=0){
	temp=0
	if !toks => return toks
	if context===:c
		env={:_globals : "map*"}
		for i=0; i<toks->len; i+=2
			void* tok=toks[i+1]
			if tok.is_func_decl()
				fn=tok.syn_func(1)
				fns[fn.name]=fn
				tok.syn_remove_default()
		fns.each fn,name,i
			fenv=env.map_dup()	
			fn.params.each op,param,i2
				fenv[param]=op.type
			fn.body.add_return().auto_types(:body,is_script,fenv,fns,fn)
			if is_script
				if fn.body => _globals.cache.userfuncs[fn.name]=fn.body
				_globals.cache.reflect.funcs[fn.name]=fn.map_del_key(:body)
		return toks.auto_types(:body,is_script,env,fns)
	else if context===:body
		for int j=0; j<toks->len; j+=2
			void* tok=toks[j+1]
			if tok.is_func_decl()
				continue
			else if tok.syn_is_macro(0)
				expanded=tok.vec_dup().syn_expand_macro(0).toks_syn()
				map* last=expanded[expanded.map_len()-1]
				expanded.vec_del(-2).vec_compact().auto_types(:body,is_script,env,fns,func)
				last.vec_merge(tok.vec_sub(8)).auto_types(:syn,is_script,env,fns,func)
				if is_script
					toks.vec_splice(j+1,1,expanded)
			else tok.auto_types(:syn,is_script,env,fns,func)
		return toks
	else if context===:syn
		if toks.is_var_decl()
			type=toks.syn_var_type()
			name=toks.syn_var_name()
			env[name]=type
			toks.auto_types(:expr,is_script,env,fns,func,toks.syn_assign_val())
		else if toks.is_flow()
			type=toks.syn_flow_name()
			if type===:for
				env=env.map_dup()
				toks.syn_flow_condition()[1].auto_types(:syn,is_script,env,fns)
			int i=0
			map* body=NULL
			while (body=toks.syn_flow_condition(i++))
				body.auto_types(:expr,is_script,env.map_dup(),fns,func)
			i=0
			while (body=toks.syn_flow_body(i++))
				body.auto_types(:body,is_script,env.map_dup(),fns,func)
		else if toks.is_assign()
			toks.auto_types(:expr,is_script,env,fns,func)
			if toks.syn_is_call(toks.map_id(1)===:return ? 2 : 0).is_word("map_val map_id")
				toks.auto_types(:expr,is_script,env,fns,func)
				from=toks.syn_assign_val()
				upto=toks.next_tok(toks.syn_assign_val(),"; =")
				len=0
				if upto => len=upto-from-1
				val=toks.vec_slice(from,len)
				toks.vec_compact().vec_del(toks.next_tok(0,"=")-1,2).vec_compact()
				toks.map_assign(val).auto_types(:expr,is_script,env,fns,func)
				return toks
			name=toks.syn_var_name()
			type=toks.syn_var_type()
			if *name!='_' && !env[name] && !type.str_len()
				type=toks.expr_type(toks.syn_assign_val(),0,env,fns)
				if type
					toks.vec_splice(1,0,"$type ".x_map().vec_del(0).vec_compact())
					env[name]=type
				else
					"$(func.name)(): unknown var $name".px()
			toks.auto_types(:expr,is_script,env,fns,func,toks.syn_assign_val())
		else
			toks.auto_types(:expr,is_script,env,fns,func)
		return toks
	else if context===:expr
		int head=idx
		for int i=idx; i<toks->len; i+=2
			if toks[i+1].is_map()
				toks[i+1].auto_types(:expr,is_script,env,fns,func)
			else if toks.syn_is_call(i)
				toks[i+5].auto_types(:expr,is_script,env,fns,func)
				name=toks.syn_is_call(i)
				if name===:args_map
					subs="xmap("
					func.params.each ,k2,i2
						subs=subs.xcat(":",k2,",",k2,",")
					mp4="$subs End)".x_map().colon_str().vec_del(0).vec_compact()
					toks.vec_splice(i+1,7,mp4)
				else
					params=toks.syn_func_param(i)
					map* fn=fns[name]
					if !fn => fn=funcs()[name]
					if fn
						params=params.param_c(env,fns,fn)
					toks.syn_set_param(i,params)
			else if toks[i+1]==="[" && toks.head_type(i-2,i,env,fns).is_word("map* void*") && toks.is_typecast(head).neq("void*") && 1
				name=toks[i+3]
				if !name.map_len() => name=[NULL,:NULL]
				head=toks.expr_head(i-2)
				mid=toks.vec_sub(head+1,i-head-1).vec_splice(0,0,[NULL]).xadd(NULL,",").vec_merge(name)
				callfunc=name.expr_type(0,0,env,fns)===:int ? :map_id : :map_val
				toks.vec_splice(head+1,i+5-head,[callfunc,NULL,"(",NULL,mid,NULL,")"])
				i=head
			else if toks[i+1]==="." && toks[i+3].is_name() && toks.expr_head(i-2)<i
				head=toks.expr_head(i-2)
				if head==i => "Can't find header for $(toks.json()) @ $i".fox_error()
				if toks.syn_is_call(i+2).is_word("each")
					mid=toks.vec_sub(head+1,i-head-1).vec_splice(0,0,[NULL])
					params=toks.syn_func_param(i+2).toks_split(",")
					if mid.syn_is_call(0)
						temp++
						varname=:map_..temp.int_str()
						toks.syn_set_param(i+2,params.vec_splice(0,0,[[NULL,varname]]).toks_join(","))
						toks.vec_splice(head+1,i-head+2,"map* $varname=".x_map().vec_splice(0,1,NULL).vec_merge(mid).vec_merge([NULL,";"," "]))
					else
						params=params.vec_splice(0,0,[mid]).toks_join(",")
						toks.syn_set_param(i+2,params)
						toks.vec_del(head+1,i-head+2)
						toks.vec_compact()
					i=head
				else if toks.syn_is_call(i+2)
					mid=toks.vec_sub(head+1,i-head-1).vec_splice(0,0,[NULL])
					toks.vec_del(head+1,i-head+2)
					params=toks.syn_func_param(i+2).toks_split(",").vec_splice(0,0,[mid])
 					params=params.toks_join(",")
					toks.syn_set_param(i+2,params)
					toks.vec_compact()
					i=head-2
				else if toks.expr_type(head,i,env,fns).is_word("map* void*") && toks.is_typecast(head).neq("void*")
					name=toks[i+3]
					mid=toks.vec_sub(head+1,i-head-1).xadd(NULL,",",NULL,name.str_unquote().str_quote()).vec_splice(0,0,[NULL])
					toks.vec_splice(head+1,i+3-head,[:map_val,NULL,"(",NULL,mid,NULL,")"])
					i=head
		return toks					
	return toks
}
map* file_callmap(char* filename) => return filename.file_funcs(1).func_depends()
map* func_depend(map* mp,map* ret={}){
	for int i=0; i<mp.map_len(); i+=2
		if mp[i+1].is_map() => mp[i+1].func_depend(ret); continue
		name=mp.syn_is_call(i)
		if name => ret[name]=funcs()[name].file
	return ret
}
map* func_depends(map* mp){
	ret={}
	mp.each fn,name
		fn.body.func_depend().each val,key => "$name $key $val".px()
	return ret
}
int utests(char* test=NULL,char* file="utests.map"){
	mp=file.file_vec()
	errs=0
	runs=0
	for int i=0; i<mp.map_len(); i+=3
		if test && !mp[i].str_has(test) => continue
		runs++
		"Running: %20s\r".printf(mp[i])
		stdout.fflush()
		errs+=mp[i+1].eval().utest(mp[i+2],mp[i+1],mp[i])
	passed=runs-errs
	"\n$passed/$runs tests passed.".px()
	return errs
}
map* cmdline_params(map* args,map* funcs){
	func=args[1]
	args=args.vec_sub(2)
	map* params=funcs[func].params
	if !params => "Function: $func() not found".fox_error()
	ret={}
	int curr=1
	int variadic=params.map_key(params.map_len()-1)==="..." ? params.map_len() : 0
	named_param=''
	args.each v,k,i
		if v.str_start("-") && v.str_len()>1
			val=''
			if named_param
				ret[named_param]=1
			if v.str_start("--")
				named_param=v.sub_str(2)
				if v.str_has("=")
					mp1=named_param.str_split("=",2)
					named_param=mp1[0]
					val=mp1[1]
				else named_param=v.sub_str(2)
			else
				named_param=v.sub_str(1)
				if !params[named_param]
					params.each v2,k2,i2
						if ret.map_has_key(k2) => continue
						if k2.str_start(named_param) => named_param=k2; break
//				if v.str_len()>2
//					val=v.sub_str(2)
			if !params[named_param] => "Invalid parameter $(named_param) in call to...\n$(funcs[func].func_cdecl())".fox_error()
			if val
				ret[named_param]=val
				named_param=NULL
		else if named_param
			ret[named_param]=v
			named_param=NULL
		else if variadic && curr>=variadic
			ret[]=v
			curr++
		else
			if curr>params.map_len() => "Excess number of arguments. Function has only $(params.map_len())\narguments $(funcs[func].func_cdecl())".fox_error()
			ret[params.map_key(curr-1)]=v
			curr++
	if named_param
		ret[named_param]=1
	ret=ret.eval_params(func,NULL,funcs)
	ret.each v3,k3,i3
		if params[k3].type==="map*"
			ret[k3]=v3.str_map()
	return ret
}
map* funcs(){
	if !_globals.cache.reflect=>_globals.cache.reflect=reflect()
	return _globals.cache.funcs ? _globals.cache.funcs : _globals.cache.reflect.funcs
}
void* fox_run(char* in){
	int halt=0
	return in.x_toks(1).fox_eval({args: _globals.args},&halt)
}
void* fox_eval(map* mp,map* env,int* halt){
	if !mp => return NULL
	assert(mp.ptr_type()==Vector)
	enum {HBreak=1, HReturn, HContinue};
	void* v=mp[1]
	void* ret=NULL
	if v.is_map()
		mp.each v3,k3,i3
			ret=v3.fox_eval(env,halt)
			if *halt => return ret
		return ret
	if v===:if
		idx=5
		while 1
			if mp[idx].eval_toks(env).is_true()
				return mp[idx+6].fox_eval(env,halt)
			else if mp[idx+10]===:else
				if mp[idx+12]===:if => idx+=16
				else return mp[idx+14].fox_eval(env,halt)
			else
				return NULL
	else if v===:while
		while mp[5].eval_toks(env).is_true()
			ret=mp[11].fox_eval(env,halt)
			if *halt==HContinue => *halt=0
			else if *halt==HBreak => *halt=0; break
			else if *halt => break
		return ret
	else if v===:for
		map* conds=mp[5]
		for conds[1].eval_toks(env); conds[3].eval_toks(env).is_true(); conds[5].eval_toks(env)
			ret=mp[11].fox_eval(env,halt)
			if *halt==HContinue => *halt=0
			else if *halt==HBreak => *halt=0; break
			else if *halt => break
		return ret
	else if v===:return
		*halt=HReturn
		return mp.eval_toks(env)
	else if v===:break
		*halt=HBreak
	else if v===:continue
		*halt=HContinue
	else if mp.is_func_decl()
		return ret
	else
		return mp.eval_toks(env)
	return ret
}
static void* eval_toks(map* mp,map* env){
	int idx=1
	return mp.eval_expr(&idx,env,0)
}
static void* eval_expr(map* mp,int* idx,map* env,int level){
	void* last=NULL
	*idx=mp.eval_expr_cont(*idx,env,&last,level)
	return last
}
void* binary_op(void* left, char oper, void* right){
	if left.is_f()||right.is_f()
		double a=left.is_double()
		double b=right.is_double()
		if oper=='+' => return (a+b).double_var()
		if oper=='-' => return (a-b).double_var()
		if oper=='/' => return (a/b).double_var()
		if oper=='*' => return (a*b).double_var()
		return 0.double_var()
		"Unknown operator $oper".fox_error()
	long long a=left.is_int()
	long long b=right.is_int()
	if oper=='+' => return (a+b).int_var()
	if oper=='-' => return (a-b).int_var()
	if oper=='/' => return (a/b).int_var()
	if oper=='*' => return (a*b).int_var()
	"Unknown operator $oper".fox_error()
	return NULL
}
int is_true(void * val){
	if !val => return 0
	if val.is_i() => return val.is_int()
	if val.is_f() => return val.is_double()
	if val.is_map() => return val.map_len()
	if val.is_str() => return val.str_len()
	return 1
}
void* eval(char* in,map* env=NULL){
	return in.x_toks().eval_toks(env)
}
int eval_expr_cont(map* mp,int idx,map* env,void** last,int level){
	if !mp => return idx
	void* ret=*last
	if(!level) level=100
	for ;idx<mp->len;idx+=2
		void* val=mp[idx];	
		if !val => continue //abnormal
		if val.is_map() => ret=val.eval_toks(env); continue
		else if val.is_num() => :int.px(); ret=val; continue
		else if val.is_numeric()
			if val.strchr('.')
				v2=0.0
				sscanf(val,"%lf",&v2)
				ret=v2.double_var()
			else
				long long v2=0
				sscanf(val,"%lld",&v2)
				ret=v2.int_var()
//				ret=atoi(val).int_var()
			continue
		else if val.fox_at(0)=='"'
			ret=val.str_unquote()
			while mp[idx+2].is_str().fox_at(0)=='"'
				ret.=mp[idx+2].str_unquote()
				idx+=2
			continue
		else if val==="&"
			name=mp[idx+2]
			if !name.is_code() => "operator& on a non variable $name".fox_error(1)
			idx1=env.map_has_key(name)
			if !idx1 => "variable $name doesn't exist".fox_error(1)
			ret=&(env->pairs[idx1-1].val)
			idx+=2
		else if val==="(" => ret=mp[idx+2].eval_toks(env); idx+=4; continue
		else if val===:End
			ret=End
			idx+=2
		else if val.is_code()
			if val===:NULL
				ret=NULL
			else if val===:_globals
				ret=_globals
			else if mp[idx+2]==="("
				params=mp[idx+4].map_split(",",0)
				params.each v,,i => params[i]=v.eval_toks(env)
				ret=params.call_func(val,env)
				idx+=6
			else if env.map_has_key(:_) && env._.map_has_key(val)
				ret=env._[val]
			else if mp[idx+2]==="="
				idx+=4
				ret=mp.eval_expr(&idx,env,6)
				env[val]=ret
			else if mp[idx+2]==="++"
				idx+=2
				env[val]=binary_op(env[val],'+',1)
			else if mp[idx+2]==="--"
				idx+=2
				env[val]=binary_op(env[val],'-',1)
			else if mp[idx+2]==="+="
				idx+=4
				env[val]=binary_op(env[val],'+',mp.eval_expr(&idx,env,6))
			else if mp[idx+2]==="-="
				idx+=4
				env[val]=binary_op(env[val],'-',mp.eval_expr(&idx,env,6))
			else if mp[idx+2]==="*="
				idx+=4
				env[val]=binary_op(env[val],'*',mp.eval_expr(&idx,env,6))
			else if mp[idx+2]==="/="
				idx+=4
				env[val]=binary_op(env[val],'/',mp.eval_expr(&idx,env,6))
			else
				ret=env[val]
			continue
		else if val==="." => if(ret.is_map()) ret=ret[mp[idx+=2-1]]; continue
		else if val==="!"
			idx+=2
			ret=mp.eval_expr(&idx,env,0)
			ret = (ret.is_i() ? !ret.is_int() : !ret).int_var()
			continue

		int clevel=1
		if level<=clevel => idx-=2; break
		if val==="/" => idx+=2; ret=binary_op(ret,'/',mp.eval_expr(&idx,env,clevel)); continue
		else if val==="*" => idx+=2; ret=binary_op(ret,'*',mp.eval_expr(&idx,env,clevel)); continue

		clevel++
		if level<=clevel => idx-=2; break
		if val==="-" => idx+=2; ret=binary_op(ret,'-',mp.eval_expr(&idx,env,clevel)); continue
		else if val==="+" => idx+=2; ret=binary_op(ret,'+',mp.eval_expr(&idx,env,clevel)); continue


		clevel++
		if level<=clevel => idx-=2; break
		if val.is_word("== !=")
			idx+=2
			void* rest=mp.eval_expr(&idx,env,clevel)
			if ret.is_i() => ret=(ret.is_int()==rest.to_int()).int_var()
			else if ret.is_str() => ret=(ret===rest).int_var()
			else ret=NULL
			if val==="!=" => ret=(!ret.is_int()).int_var()
			continue
		else if val.is_word("> < >= <=")
			idx+=2
			int val1=ret.is_int()
			int val2=mp.eval_expr(&idx,env,clevel).is_int()
			if val===">" => val1=val1>val2
			else if val==="<" => val1=val1<val2
			else if val==="<=" => val1=val1<=val2
			else if val===">=" => val1=val1>=val2
			ret=val1.int_var()
			continue

		clevel++
		if level<=clevel => idx-=2; break
		if val==="&&"
			idx+=2
			if ret.is_true() => ret=mp.eval_expr(&idx,env,clevel)
			else
				while idx<mp->len-2
					if mp[idx].is_word("&& || ? :") => idx-=2; break
					idx+=2
			continue
		
		clevel++
		if(level<=clevel){ idx-=2; break; }
		if val==="||"
			idx+=2
			if ret.is_true() => break
			else ret=mp.eval_expr(&idx,env,clevel)
			continue

		clevel++
		if(level<=clevel){ idx-=2; break; }
		if val==="?"
			idx+=2
			if ret.is_true()
				ret=mp.eval_expr(&idx,env,clevel)
				break
			else
				while idx<mp->len && mp[idx]!==":" => idx+=2
				continue
		if val===":"
			break

		clevel++
		if(level<=clevel){ idx-=2; break; }
		if val==="="
			idx+=2
			if !ret.is_str() => "eval() in name=value name should be a valid name".fox_error()
			void* val=mp.eval_expr(&idx,env,clevel)
			env[ret]=val
			ret=val
			continue

	*last=ret
	return idx
}
map* eval_params(map* sent,char* name,map* env=NULL,map* fns=funcs()){
	name.assert()
	ret={}
	fn=fns[name]
	if !fn => "Function $name() not found".fox_error()
	named=0
	fn.params.each v,k,i
		if k==="..."
			for int i2=i; i2<sent->len; i2++
				ret[]=sent[i2]
			break
		else if sent.map_has_key(k)
			named=1
			ret[k]=sent[k]
		else if !named && sent.map_len()>i && sent.map_key(i).is_i()
			ret[k]=sent[i]
		else if env.map_has_key(k)
			named=1
			ret[k]=env[k]
		else if k===:env
			ret[k]=env
		else if v.default
			ret[k]=v.default.eval()
		else
			"Parameter missing in $(fn.name)($k=?) in $(fn.func_cdecl())\nargs=$(sent.json())".fox_error()
			assert(0)
	return ret
}
void* data_exec(void* data,map* env=NULL){
	if !data => return NULL
	if data.is_str() => return data	
	if !data.is_map() => return data.to_str()
	char* func=data[0]
	return data.map_del(0).vec_compact().call_func(func,env)
}
void* call_func(map* params,char* name,map* env=NULL){
	params=params.eval_params(name,env)
	if name.str_start(:php_) => return params.call_php(name.sub_str(5))
	map* user=_globals.cache.userfuncs[name]
	void* ret=NULL
	if user
		int halt=0
		ret=user.fox_eval(params,&halt)
	else
		ret=params.invoke(name)
	return ret
}
map* ping_map(map* in) => return in
