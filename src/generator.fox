#line 2 "src/generator.fox"
#include <core.h>
#include <generator.h>
#include <foxtime.h>
#include <playground.h>
#include <cmd.h>
#include <dir.h>
#include <tsv.h>
#include <map.h>
#include <foxparser.h>
#include <cmdline.h>

extern void* (*invoke)(map* v,char* name);
extern map* (*reflect)();
void* (*invoke)(map* v,char* name)=NULL;
map* (*reflect)()=NULL;

#define MAXMEM 40*1024*1024
#define MIN_CHAIN 1
int _iscmd=0;

int cgi(char* infile="index.fox", char* xfiles='', char* profile=:release, char* outfile="index.cgi",char* opts=NULL,int keepfiles=1){
	return infile.cc(xfiles, profile, outfile, opts, keepfiles)
}
static char* fox_meta(char* infile, char* name, map* depends, char* outfile=''){
	funcs=infile.file_funcs().funcs_nonstatic()
	macros=infile.c_macros()
	structs=infile.c_structs()
	depends.each file
		funcs=(file..".fox").file_funcs().funcs_nonstatic().map_merge(funcs)
		macros=(file..".fox").c_macros().map_merge(macros)
		structs=(file..".fox").c_structs().map_merge(structs)

	prefix=name.."_"
	return ---
	/* This is a generated file. To change it, edit function fox_meta() in generator.fox */
	#include "$name.h"
	void* $(prefix)invoke(map* v,char* name){
		unsigned long long idn=str_hash((unsigned char*)name)
		switch(idn){
	//$(funcs.callfunc_c())
		}
		return End
	}
	map* $(prefix)reflect(){
		return {
			funcs: $(funcs.map_ccode()),
			macros: $(macros.map_ccode()),
			structs: $(structs.map_ccode())
		}
	}

	---.x_c().write_file(outfile)
}
map* file_deps(char* filename, map* deps={}){
	map* pragmas=_globals.reflect.pragmas
	filename.fox_includes().each f
		deps=deps.map_merge(pragmas[f])
	val=filename.fox_pragma()
	if val => deps[val]=val
	return deps //.map_vec().vec_reverse()
}
int vec_has(map* in, char* key){
	in.each val
		if val===key => return 1
	return 0
}
int cc(char* infile, char* xfiles='', char* profile="release", char* outfile=NULL, char* opts=NULL, int keepfiles=0){
	libs={}
	names=[]
	xfiles.str_split(",").each file
		names[]=file.file_rename(,".fox").fox_cs()
		libs=file.file_deps(libs)
	name=infile.file_rename(,".fox")
	hasmeta=infile.fox_includes().vec_has(name.."_meta")
	name.fox_cs(names, hasmeta)
	libs=infile.file_deps(libs)
	xlibs=libs.map_join(" ")
	if !outfile => outfile=name
	// -lfoxstatic
	cflags="-m64 -std=gnu99 -Werror=implicit-function-declaration -L/usr/local/lib -lm -I/usr/local/include"
	switches={
		debug: "-g -lfoxcmdstatic"
		release: "-O2 -lfoxcmdstatic"
		cgi: "-O2 -lfcgi"
		cgidebug: "-g -lfcgi"
	}
	profile = switches[profile] or switches.debug
	extras=''
	if names.map_len() => extras=names.map_join(".c ")..".c"
	if hasmeta => extras.=" $(name)_meta.c"
	ret="gcc $name.c $extras -o $outfile $opts $cflags $xlibs $profile"
		.px()
		.exec()
	return ret
}
char* write_user_meta(char* name, map* depends=NULL){
	_globals.reflect.funcs.map_merge(name.meta_h().x_funcs(name.."_meta.c"))
	name.meta_h().write_file(name.."_meta.h")
	meta=''
	meta.=---
	extern int _iscmd;
	int cmdline(){
		args=_globals.args
		if !args[1].is_code() => return 0
		_iscmd=1
		reflect=$(name)_reflect
		invoke=$(name)_invoke
		args.cmdline_params($(name)_reflect().funcs).$(name)_invoke(args[1]).ret_print()
		return 1
	}

	---;
	meta=meta.x_c()
	((name..".fox").fox_meta(name,depends)..meta).write_file(name.."_meta.c")
}
static char* fox_cs(char* name,map* depends=NULL,int addmeta=0){
	fox=name..".fox"
	func=fox.file_funcs()
	_globals.reflect.funcs.map_merge(func)
	if addmeta => name.write_user_meta(depends)
	fox.fox_c().exclude_defines().write_file(name..".c")
	fox.fox_h(name..".h")
	return name
}
void write_source(char* infile, char* ...){
	files=[infile]
	va_list args
	args.va_start(infile)
	while 1
		char* name=args.va_arg(char*)
		if name==End => break
		files[]=name
	args.va_end()
	files.source_funcs()
	includes=''
	files.each infile
		includes.="#include <"..infile.file_noext().file_nodir()..".h>\n"
		if infile.str_end(".h") => continue
		infile.fox_c().exclude_defines().write_file(infile.file_rename(:src,".fox")..".c")
		infile.fox_h(infile.file_rename(:include,".fox")..".h")
	data={}
	data.funcs=source_funcs().funcs_nonstatic()
	data.macros=files.files_section("#define").c_macros()
	data.structs=files.files_section("typedef struct union class enum").c_structs()
	data.pragmas=files.source_pragmas()
	data.funcs.each val,name
		data.depends[name]=val.body.func_depend()
		val.map_del_key(:body)
	data.version.build=increase_version()
	data.version.date=time_str(0)
	("#include <meta.h>\n"..includes..data.funcs_meta("fox")).write_file("meta.c".file_rename(:src))
	---
	#pragma once
	#include <core.h>
	void* fox_invoke(map* v,char* name);
	map* fox_reflect();

	---.write_file("include/fox_meta.h");
	mem_usage().px()
}
map* source_pragmas(map* infiles, map* ret={}){
	deps={}
	ret={}
	modules={}
	infiles.each file
		if file.file_ext()!==:fox => continue
		module=file.file_noext().file_nodir()
		ret[module]["-lfox$(module)static"]="-lfox$(module)static"
		val=file.fox_pragma()
		if val => ret[module][val]=val
		deps[module]=file.fox_includes()
	found=1
	while found
		found=0
		deps.each ds, module
			ds.each mod
				ret[mod].each cmd	
					if !ret[module][cmd]
						ret[module][cmd]=cmd
						found++
	return ret
}
map* fox_includes(char* infile){
	ret=[]
	toks=infile.file_read().str_ltrim("\n").str_tokenize("\n")
	toks.each tok,,i=0 step 2
		if !tok.str_start("#include")
			continue
		words=tok.str_tokenize(" \t")
		ret[]=words[2].sub_str(1,-1).file_noext().file_nodir()
	return ret
}
char* fox_pragma(char* infile){
	toks=[infile].files_section("#pragma").str_split("\n")
	toks.each tok
		words=tok.str_tokenize(" \t")
		if words[2]!==:fox
			continue
		if words[4]!==:cc
			continue
		return words.vec_sub(6).map_join()
	return NULL
}
char* source_defines(map* infiles){
	ret=''
	infiles.each v,,i
		ret.=v.fox_defines()
	return ret
}
char* exclude_defines(char* in){
	if !in => return NULL
	toks=in.str_tokenize("\n")
	start=0
	ret=''
	if toks[0].str_chr('\n')
		start++
		ret.=toks[0]
	toks.each tok,,i=start step 2
		if tok.tok_isdefine()
			ret.="//"..tok.str_replace("\n","\n//")
		else
			ret.=tok
		ret.=toks[i+1]
	return ret
}
int tok_isdefine(char* in){
	type=in.next_word(" \t\n")
	if !type.is_word("typedef struct enum union class extern")
		return 0
	if type==="struct"
		words=in.str_tokenize(" \t{}")
		if !words[3].str_chr('{') => return 0
	return 1
}
char* fox_defines(char* infile){
	toks=infile.file_read().str_ltrim("\n").str_tokenize("\n")
	basename=infile.file_nodir().file_noext()
	ret=''
	toks.each tok,,i=0 step 2
		type=tok.next_word(" \t\n")
		if !type.is_word("typedef struct enum union class #include #pragma extern #define #if #ifdef #undef #else #endif #ifndef")
			continue
		if type==="struct"
			words=tok.str_tokenize(" \t{}")
			if !words[3].str_chr('{')
				continue
		if type==="#include"
			words=tok.str_tokenize(" \t<>")
			filename=words[2].file_nodir().file_noext()
			if filename===basename
				ret.="#pragma fox module $filename\n"
				continue
		ret.=tok.."\n"
	return ret
}
static map* funcs_nonstatic(map* funcs){
	ret={}
	funcs.each val, key
		if val.isstatic => continue
		ret[key]=val
	return ret
}
static char* meta_h(char* prefix=''){
	prefix&&=prefix.."_"
	return ---
	#pragma once
	void* $(prefix)invoke(map* v,char* name);
	map* $(prefix)reflect();
	int cmdline();
	int exec_cmdline(map* args);
	void* user_invoke(map* params, char* name);
	map* user_funcs();

	---;
}
static char* funcs_meta(map* data, char* prefix=''){
	prefix&&=prefix.."_"
	return ---
	/* This is a generated file. To change it, edit function funcs_meta() in generator.fox */
	void* $(prefix)invoke(map* v,char* name){
		unsigned long long idn=str_hash((unsigned char*)name);
		switch(idn){
	//$(data.funcs.callfunc_c())
		}
		return fox_error(xstr("invoke(): Function %s not defined", name, End), 0);
	}
	map* $(prefix)reflect(){
		return xmap(
			"funcs", $(data.funcs.map_ccode()),
			"macros", $(data.macros.map_ccode()),
			"structs", $(data.structs.map_ccode()),
			"depends", $(data.depends.map_ccode()),
			"pragmas", $(data.pragmas.map_ccode()),
			"version", $(data.version.map_ccode()), End
		);
	}

	---;
}
static char* gen_htaccess(char* outfile=NULL){
	return ---
	RewriteEngine On
	RewriteCond %{REQUEST_FILENAME} !-f
	RewriteCond %{REQUEST_FILENAME} !-d
	RewriteRule ^(.+)$ index.cgi [L,QSA]
	Options -Indexes
	<FilesMatch "\.(db|txt|sql)$">
	Order allow,deny
	Deny from all
	</FilesMatch>

	---.write_file(outfile)
}
static char* gen_cgi_makefile(char* name, char* outfile=NULL){
	return ---
	all:
		fox cgi $name.fox
	debug:
		fox cgi $name.fox --profile=cgidebug
	
	---.write_file(outfile)
}
static char* gen_fox_cgi(char* name,char* outfile=NULL){
	return ---
	#line 2 "$name.fox"

	#include <fcgi_stdio.h> /* fcgi library; put it first*/
	#include <core.h>
	#include <syslog.h>
	#include "$name.h"

	int run(map* args){
		_globals.dbs.$name="$name.db"
		if cmdline() => return 0
		LOG_INFO.syslog("fox.fcgi started")
		while FCGI_Accept() >= 0
			ret=http_req().dispatch()
			//close_conns()
			_queries=0
			"%s".printf(ret or "content-type: text/html\r\n\r\nBody is Blank!")
			//gc_reset()
		LOG_INFO.syslog("fox.fcgi exit")
		return 0
	}

	char* dispatch(map* req){
		path=_globals.paths
		if "/".get().end
			return "Hello World! - from $name.".show_body{{
				title $(name.str_title())'s Application
			}}

		return not_found()
	}

	---.write_file(outfile)
}
int init_fox(char* name){
	if !:Makefile.is_file()
		---
		all:
			fox cc $name.fox
			./$name
		debug:
			fox cc $name.fox --profile=debug
			./$name
		fox:
			pushd . && cd /web/fox2 && make install && popd
		
		---.write_file(:Makefile)
	filename="$name.fox"
	if !filename.is_file()
		---
		#line 2 "$name.fox"
		#include <core.h>
		#include "$name.h"

		int run(map* args){
			return 0
		}

		---.write_file(filename)
	return 0
}
int init_cgi(char* name){
	if !(name..".fox").is_file() => name.gen_fox_cgi(name..".fox")
	if !".htaccess".is_file() => ".htaccess".gen_htaccess()
	if !:Makefile.is_file() => name.gen_cgi_makefile(:Makefile)
	return 0
}
char* c_h(char* infile,char* outfile=NULL) => return infile.file_funcs().funcs_cdecl(0).write_file(outfile)
char* fox_h(char* infile,char* outfile=NULL){
	return ("#pragma once\n"..infile.fox_defines()..infile.file_funcs().funcs_cdecl(0)).write_file(outfile)
}
//static
char* c_x(char* in) => return in.x_map().map_tox().toks_c()

static char* map_ccode(void* mp){
	if !mp => return :NULL
	if mp.is_str() => return mp.str_quote()
	if mp.is_int() => return mp.is_int().int_str()
	if mp.ptr_type()==Map
		if(!mp.map_len()) return "new_map()"
		ret="xmap("
		mp.each v,k,i
			ret.="$(k.str_quote()),$(v.map_ccode()),"
		return ret.."End)"
	if mp.ptr_type()==Vector
		if(!mp.map_len()) return "new_vec()"
		ret="xvec("
		mp.each v1,,i1
			ret.="$(v1.map_ccode()),"
		return ret.."End)"
	return "Unknown type of variable $(mp.to_str())".fox_error()	
}
static char* file_foxh(char* infile,char* outfile=NULL){
	return infile.file_funcs().funcs_cdecl(1).write_file(outfile)
}
//static
char* funcs_cdecl(map* fns=funcs(),int show_default=1){
	ret=""
	fns.each v, k, i
		if k.is_word("main") => continue
		ret.=v.func_cdecl(show_default)
		ret.="\n"
	return ret
}
static char* old_decl_type(map* mp,int idx){
	int from=mp.stm_start(idx,"{};,().>:=><!&-+/?")
	for int i=from;i<idx;i+=2
		if mp[i].is_word("int long double float char void struct map static extern unsigned register mempage size_t time_t const var")
			return mp.vec_sub(from,idx-from-1).toks_c()
	return NULL
}
static char* toks_str(map* mp){
	ret=''
	mp.each val => ret.=val.is_map() ? val.toks_str() : val
	return ret
}
static map* toks_keywords(map* mp,char* keywords){
	if !mp => return mp
	ret={}
	curr=[]
	curr_key=''
	mp.each ,,i
		if mp[i].is_word(keywords)
			if curr->len
				ret[curr_key]=curr.toks_align()
				curr=[]
			curr_key=mp[i]
			continue
		curr[]=mp[i]
	if curr->len => ret[curr_key]=curr.toks_align()
	return ret
}
static int is_keyword(char* str) => return str.is_word("abstract and as break callable case catch class clone const continue declare default do echo else elseif enddeclare endfor endforeach endif endswitch endwhile extends final for foreach def function global goto if implements include include_once instanceof insteadof interface namespace new or private protected public require require_once return static switch throw trait try use while xor yield false true null")
static char* toks_c(map* mp){
	ret=''
	if !mp => return ret
	mp.each ,,i
		if mp[i].is_map()
			ret.=mp[i].toks_c()
			continue
		str=mp[i].is_str()
		assert(str || !mp[i].is_str())
		if !str => continue
		ret.=mp[i]
	return ret
}
static int func_dot(map* mp,int idx){
	idx++
	if mp[idx]!=="(" => return idx
	if !mp[idx-2].is_str().is_code() => return idx
	if mp[idx-4]==="." => return idx
	if mp[idx-2].is_str().is_keyword() => return idx
	params=mp[idx+2].is_map()
	if !params->len => return idx
	if params[1].ptr_type()!=String && !params[1].is_str().is_code() => return idx
	int len=2
	while 1
		s=params[len+1].is_str()
		if s.is_word("( [ {") => len+=6
		else if s.is_word(". ->") || s.is_code() => len+=2
		else break
	
	if params->len>len && params[len+1]!=="," => return idx
	out=params.vec_slice(1,len-1)
	params.vec_del(0,1)
	if params->len>len => params.vec_del(len,2)
	vec_compact(params)
	out.xadd(NULL,".",NULL)
	mp.vec_splice(idx-1-1,0,out)
	mp.vec_compact()
	return idx-3
}
static map* multiline_parts(char* str){
	lines=str.sub_str(1,-1).str_split("\n",0)
	indent=0
	end=str+str.str_len()-1
	while(end>str){ if("\t\n\r".strchr(*end)) break; end--; }
	while(end>str){ if(*end!='\t') break; end--; indent++; }
	tabs="\t".str_times(indent).null_str()
	parts=[]
	lines.each v,,i
		int cut=v.str_level()
		if cut>indent => cut=indent;	
		nl=""
		if i<lines.map_len()-1
			nl="\\n"
		if i => parts[]="\n"..tabs
		parts[]="\"%s%s\"".mstr(v.sub_str(cut).str_escape(),nl)
	return parts
}
static map* heredoc_parts(char* str){
//	if !str.is_str() => return NULL
	if !str || !str.is_str() ||!*str => return NULL
	if !((*str=='\'' && str.strchr('\n'))||(*str=='"' && str[1]!='"' && str.strchr('\n'))||str.str_start("---")) => return NULL
	if "\"`".str_chr(*str) => return str.multiline_parts()
	lines=str.str_split("\n",0)
	indent=0
	end=str+str.str_len()-1
	while(end>str){ if("\t\n\r".strchr(*end)) break; end--; }
	while(end>str){ if(*end!='\t') break; end--; indent++; }
	tabs="\t".str_times(indent).null_str()
	parts=["\"\""]
	lines.each v,,i
		if i==0 => continue
		if i==lines->len-1 => continue
		int cut=v.str_level()
		if cut>indent => cut=indent;	
		nl="\\n"
		if i==lines->len-2 => nl=""
		parts[]="\n"..tabs
		parts[]="\"%s%s\"".mstr(v.sub_str(cut).str_escape(),nl)
	parts.xadd("\n"..tabs,"\"\"")
	return parts
}
static map* heredoc_str(map* mp){
	for int idx=1; idx<mp.map_len(); idx+=2
		if mp[idx].is_map() => mp[idx].heredoc_str()
		parts=mp[idx].heredoc_parts()
		if !parts => continue
		mp.vec_splice(idx,1,parts)
	return mp
}
static map* dot_each(map* mp){
	int temp=0
	for int idx=1; idx<=mp->len; idx+=2
		if mp[idx].is_map() => mp[idx].dot_each()
		if idx<2 || !mp[idx-2].is_str().is_word("each each_mem")
			continue
		params=mp[idx+2].is_map().toks_split(",")
		newp=mp[idx+2].is_map().toks_split(",")
		if params[0].map_len()>=4
			temp++
			temp_name=:map_..temp.int_str()
			pre=xcat("map* ",temp_name.."=",params[0].toks_c(),"; ").x_map().vec_del(0).vec_compact()
			newp[0]=temp_name.x_map()
			mp[idx+2]=newp.toks_join(",")
			mp.vec_splice(idx-2,0,pre)
			assert(mp[pre.map_len()-3+idx]===" ")
		if mp[idx-2]===:each
			next1=:next1
			start="-1"
			upto=''
			step="++"
			if params[3][1]
				incs=params[3].toks_keywords("= to step")
				next1=incs[0].toks_c()
				if incs["="]
					start=incs["="].toks_c().str_trim()
					if start.is_numeric() => start=(start.to_int()-1).int_str()
					else start.="-1"
					if incs.to
						upto=" $next1<="..incs.to.toks_c().str_trim().." &&"
					if incs.step
						step=incs.step.toks_c().str_trim()
						if step.is_numeric() && step.to_int()==1 => step="++"
						else if step[0]=='-'
							step="-="..(step+1)
						else step="+="..step

			mpname=params[0].toks_c()
			expr="int $next1=next($mpname,$start);$upto has_id($mpname,$next1); $next1$step"
			mp[idx-2]=:for
			mp[idx+2]=expr.x_map()
			expr=''
			if params[1][1]
				if params[1].map_len()<=2 => expr.=" void* "
				else expr.=" "
				expr.=params[1].toks_c().."=map_id($mpname,$next1);"
			if params[2][1]
				expr.=" char* "..params[2].toks_c().."=map_key($mpname, $next1);"
			mp[idx+8].vec_splice(0,0,expr.x_map())
	return mp
}
static int tok_indent(char* str){
	if !str => return 0
	if !str.strchr('\n') => return 0
	int ret=1
	for int i=str.str_len()-1;i>=0;i--
		if "\t ".strchr(str[i]) => ret++
		else if "\n\r".strchr(str[i]) => break
		else ret=1
	
	return ret
}
static int requires_semicolon(map* mp,int idx){
	idx++
	if idx<2 => return 0
	if !mp[idx-1].str_chr('\n') => return 0
	pre=mp[idx-2].is_str()
	if !pre => return 0
	post=mp[idx].is_str()
	if pre==="}" && post.is_word(:else) => return 0
	if post===")" => return 0
	if pre===";" || post===";" => return 0
	forbidden="+=-/?:.&,|!%"
	if (forbidden.strchr(pre.fox_at(-1))||post && forbidden.strchr(post[0])) && !pre.is_word("++ --") && !post.str_start("---") => return 0
	return 1
}
static map* add_semicolon(map* mp,int recurse=1){
	if(!mp) return mp
	for(int idx=1;idx<mp->len;idx+=2)
		if recurse && mp[idx]==="{" && (mp[idx-2]===")" || (mp[idx-2].is_keyword() && !mp[idx-2].is_word("return")))
			mp[idx+2].add_semicolon()
			idx+=4
			continue
		if(mp.requires_semicolon(idx-1)) mp.vec_splice(idx-1,0,[NULL,";"])//.vec_sub(idx-6,12).px()
	if(!mp[mp->len-mp->len%2-1].is_word(";"))
		mp.vec_splice(mp->len-mp->len%2,0,[NULL,";"])
	return mp
}
static int tok_endl(map* mp,int from){
	for ;from<=mp->len;from+=2 => if(mp[from-1].is_str().str_chr('\n')) break
	return from
}
static map* force_curly(map* mp){
	if !mp.is_map() => return mp
	for int idx=1; idx<mp->len; idx+=2
		if mp[idx].is_map() => mp[idx].force_curly()
		w=mp[idx].is_str()
		if !w => continue
		if !w.is_word("if while for each do else each_mem")
			continue
		if w.is_word(:else) && mp[idx+2]===:if => continue
		int curly_at=9
		if w.is_word("else do") => curly_at=3
		if w===:while && idx>8 && mp[idx-8]===:do => continue
		if mp[idx+curly_at-1]==="{" => continue
		oldidx=idx
		idx+=curly_at
		from=idx
		if mp->len<from
			if !(mp->len%2) => mp[]=" "
			mp.xadd("{",NULL,NULL,NULL,"}",NULL,";")
			continue
		upto=idx
		while upto<mp->len
			if upto>mp->len
				upto-=2
				break
			if mp[upto].tok_indent() => break
			if(mp[upto-1]===";") => break
			upto+=2
		subs=[NULL]
		subs.vec_merge(mp.vec_sub(from-1,upto-from+1))
		if subs[subs.map_len()-subs.map_len()%2-1]!==";"
			if !(subs.map_len()%2) => subs.xadd(NULL)
			subs.xadd(";")
		mp.vec_splice(from-1,upto-from+1,["{",NULL,subs,NULL,"}"])
		idx=oldidx
	return mp
}
static map* expand_main(map* mp){
	for int idx=1;idx<=mp->len;idx+=2
		if mp[idx]===:run && mp[idx+2]==="(" && mp[idx+8]==="{" && !mp[idx+4].map_len() && mp[idx-2]!==:int
			mp.vec_splice(idx,7,"void* run(map* args)".x_map().vec_del(0,1)).vec_compact()
	return mp
}
static map* add_curly(map* mp,int recursive=1){
	for(int idx=1;idx<=mp->len;idx+=2)
		if(mp[idx]==="=>")
			int from=idx
			int upto=mp.tok_endl(idx+2)
			mp.vec_splice(from-1,upto-from,[NULL,"{",NULL,mp.vec_sub(from+1,upto-from-2)," ","}"]).vec_compact()
		if !recursive => continue
		if(mp[idx]==="{")
			mp[idx+2].add_curly()
			idx+=4
			continue
		w=mp[idx].is_str()
		if !w => continue
		if !w.is_word("if while switch for each do else each_mem") => continue
		if w.is_word(:else) && mp[idx+2]===:if && !mp[idx+1].block_level() => continue
		int from=0
		int upto=0
		if(mp[idx+1].is_str().str_chr(' ') && !w.is_word("else do"))
			from=idx+2
			upto=mp->len-mp->len%2
			for(int i=from;i<=mp->len;i+=2)
				if(mp[i-1].tok_indent() || mp[i]==="=>")
					upto=i-1
					break
			mp[idx+1]=NULL
			sub=[ NULL,"(", NULL,mp.vec_sub(from-1,upto-from+1), NULL,")"]
			if w.is_word(:while) && mp[idx-2]==="}" && mp[idx-8]===:do
				sub.xadd(NULL,";")
			mp.vec_splice(from-1,upto-from+1,sub).vec_compact()

		if idx>=8 && w.is_word(:while) && mp[idx-2]==="}" && mp[idx-8]===:do => continue

		//if:1 (:3 x:5 ):7 {:9
		int curly_at=9
		if(w.is_word("else do")) curly_at=3
		if(!mp[idx+curly_at-2].tok_indent() && mp[idx+curly_at-1]==="{") continue
		if(!mp[idx+curly_at-2].tok_indent()) // "else i=3;"
			continue
		int curr_indent=0
		for int i=idx;i>0;i-=2
			int ind=mp[i-1].tok_indent()
			if(!ind) continue
			curr_indent=ind
			break
		if(!curr_indent && mp[0].str_level()) curr_indent=mp[0].str_level()+1
		if(!curr_indent) curr_indent=1
		from=idx+curly_at-1
		upto=mp->len-mp->len%2
		for(int i=from;i<=mp->len;i+=2)
			int ind=mp[i-1].tok_indent()
			if(ind && ind<=curr_indent)
				upto=i-1
				break
		if(curr_indent) curr_indent--
		space=" "
		blankline=mp[upto].is_str()
		tail=''
		if(blankline)
			lns=blankline.str_split("\n",3)
			if(((lns->len==3||(lns->len==2 && mp->len==upto+1)) && !lns[1].has_chars()) || w.is_word(:do) || (w.is_word(:if) && mp[upto+1]===:else))
				if(lns->len==3) tail="\n"..lns[2]
				else tail=lns[2]
				space=lns[0].."\n".."\t".str_times(curr_indent)
				mp[upto]=tail
		mp.vec_splice(from-1,upto-from+1,[NULL,"{",NULL,mp.vec_sub(from-1,upto-from+1),space,"}"]).vec_compact()
	return mp
}
static map* dot_key(map* mp){
	return mp
	for(int idx=1;idx<=mp.map_len();idx+=2)
		if mp[idx].is_map() => mp[idx].dot_key(); continue
		str=mp[idx].is_str()
		if !str => continue
		if idx>=2 && *str=='"' && mp[idx-2]==="."
			mp.vec_splice(idx,1,[:map_val,NULL,"(",NULL,[NULL,str],NULL,")"])
	return mp
}
static int str_hasvar(char* in){
	if !in => return 0
	for int i=0; i<in.strlen(); i++
		if in[i]!='$' => continue
		if in[i+1].is_alpha("($") => return 1
	return 0
}
static char* str_mstr(char* in){
	ret=in.str_len().new_str()
	rethead=ret
	type=''
	str=in
	params=[]
	expr=''
	for ;*str;str++
		if *str=='%'	
			if str[1]=='%'
				str++
			else
				type=str+1
		else if type && *str=='{'
			if type==str
				*ret++='s'
			expr=str+1
			type=NULL
			continue
		else if type && !"cdieEfgGosuxXpnhlL* +-#0123456789.".strchr(*str)
			type=NULL
		else if expr && *str=='}'
			params[]=expr.sub_str(0,str-expr)
			expr=NULL
			continue
		if !expr
			*ret++=*str
	if !params->len => return in
	args=params.map_join(", ")
	return "mstr($(rethead), $(args), End)"
}
static map* xstr_parts(char* in){
	ret=[]
	tok=in.str_len().new_str()
	tokhead=tok
	incode=0
	str=in
	if "\"'".strchr(*str) => str=str.sub_str(1,-1)//.str_unquote()
	while 1
		if incode
			if incode>1 && *str=='('
				incode++
			else if *str==')'
				incode--
				if incode==1 => incode=0; if *str => str++
			else if incode==1 && !is_alphanum(*str)
				incode=0
			if !incode || !*str
				*tok='\0'
				if tokhead.str_len() => ret[]=tokhead.str_dup()
				tok=tokhead
		if !incode
			if *str=='$'
				if str[1]=='$'
					str++
				else if str[1].is_alpha()
					incode=1
					str++
				else if str[1]=='('
					incode=2
					str+=2
					if *str=='(' => incode++
			if incode || !*str
				*tok='\0'
				if tokhead.str_len() => ret[]=tokhead.str_quote()
				tok=tokhead
		if !*str => break
		*tok++=*str++
	return ret
}
static char* str_xstr(char* in){
	parts=in.heredoc_parts()
	if parts
		nparts=[]
		parts.each val,,idx
			if idx%2 => continue
			if !val.str_hasvar()
				nparts[]=idx ? parts[idx-1]..val : val
			else
				xparts=val.str_unquote().xstr_parts()
				if idx => xparts[0]=parts[idx-1]..xparts[0]
				nparts.vec_merge(xparts)
		ret="xstr($(nparts.map_join(\", \")))"
		return ret
			
	ret=in.str_unquote().xstr_parts()
	return ret.map_len()==1 ? ret[0] : "xstr(%s)".mstr(ret.map_join(", "))
}
static map* str_dollars(map* mp){
	if !mp => return mp
	assert(mp.is_map())
	for int idx=1; idx<mp.map_len(); idx+=2
		if mp[idx].is_map()
			mp[idx].str_dollars()
			continue
		str=mp[idx].is_str()
		if !str => continue
		if (*str=='"' || str.str_start("---")) && str.str_hasvar()
			subs=str.str_xstr().x_map().colon_str().dot_key().vec_sub(1)
			mp.vec_splice(idx,1,subs)
			idx+=subs.map_len()-1
	return mp
}
static map* single_quotes(map* mp){
	for(int idx=1;idx<=mp.map_len();idx+=2)
		if mp[idx].is_map() => mp[idx].single_quotes(); continue
		str=mp[idx].is_str()
		if !str => continue
		if str==="''"
			mp[idx]=:NULL
		else if *str=='\'' && (str.str_len()>4 || (str[1]!='\\' && str.str_len()>3))
			*str='"'
			str[str.str_len()-1]='"'
	return mp
}
static map* colon_str(map* mp){
	for(int idx=1;idx<=mp.map_len();idx+=2)
		if mp[idx].is_map() => mp[idx].colon_str(); continue
		str=mp[idx].is_str()
		if !str => continue
		if str.str_len()>1 && *str==':'
			str=str.sub_str(1).str_unquote().str_quote()
			mp[idx]=str
		if idx>=2 && *str=='"' && mp[idx-2]==="."
			mp.vec_splice(idx,1,[:map_val,NULL,"(",NULL,[NULL,str],NULL,")"])
	return mp
}
static map* dot_func(map* mp){
	for int i9=0;i9<mp.map_len();i9+=2
		if mp[i9+1].is_map()
			mp[i9+1].dot_func()
			continue
		idx=i9+1
		if idx<=2 => continue
		if mp[idx]!=="." => continue
		if !mp[idx+2].is_str().is_code() => continue
		if mp[idx+4]!=="(" => continue
		int from=idx-2
		while from>0
			s=mp[from].is_str()
			if !s => break
			s2=mp[from+2].is_str()
			if(s.is_word(") } ]") && s2.is_word(". -> ( [")) from-=6
			else if(s.is_word(". ->") || *s=='"' || *s=='\'' || s.str_start("---")) from-=2
			else if((s.is_code()||s.is_numeric()) && s2.is_word(". -> ( { [")) from-=2
			else break
		if mp[from+2]===:return => from+=2
		if idx-from<=2 => continue
		prespace=mp[idx-1].is_str()
		mp.vec_del(idx-1,2).vec_compact()
		from+=2
		idx-=2
		sub=mp.vec_slice(from,idx-from+2)
		sub.each ,,idx2
			if(sub[idx2].is_str().fox_at(0)==')' && sub[idx2+2].is_str().fox_at(0)=='(') sub.vec_shift(idx2+2,6,-idx2-2)
			//if(sub[idx].is_str().fox_at(0)==')' && sub[idx+2].is_str().fox_at(0)=='(') sub.vec_shift(idx+2,6,-idx-2)
			idx2++
		params=mp[idx+6].is_map()
		params.assert()
		if !params => params=mp->vars[idx+6]=[]
		if params->len => sub.xadd(",")
		else sub.vec_del(sub->len-1,1).vec_compact()
		sub1=[]
		sub1[]=prespace
		sub1.vec_merge(sub)
		params.vec_splice(1-1,0,sub1)
		params.vec_compact()
		params.dot_func()
		mp.vec_compact()
		i9-=4
	return mp
}

static map* map_tox(map* mp){
	if !mp => return mp
	for int idx=1+next(mp,-1);idx;idx=1+next(mp,idx-1)
		if idx%2-1
			mp1=mp[idx-1].is_map()
			if(mp1) mp1.map_tox()
			continue
		idx=mp.func_dot(idx-1)
	return mp
}
static int stm_start(map* mp,int idx,char* terms="};,).>:"){
	idx-=2
	while idx>0
		if terms.str_chr(mp[idx].fox_at(0)) => break
		idx-=2
	return idx+2
}
static map* syn_func(map* syn,int with_body=0,char* filename=NULL){
	len=syn.map_len()
	map* body=NULL
	params_at=5
	if syn[len-3]==="}"
		body=syn[len-5]
		params_at=11
	params={}
	mp1=syn[len-params_at].toks_split(",")
	mp1.each v,,i2
		param_name=v.syn_var_name()
		param_type=v.syn_var_type()
		void* param_default= v.is_assign() ? param_default=v.vec_sub(v.syn_assign_val()).toks_c() : NULL
		if param_name!=="..." && !param_type
			"$(syn[len-params_at-4])() parameter $param_name type not set".fox_error()
		assert(param_name==="..." || param_type)
		assert(param_name)
		params[param_name]={type: param_type, default: param_default}
	name=syn[len-params_at-4].is_str()
	type=syn.vec_sub(1,len-params_at-6)
	decltype=type.toks_c()
	isstatic=''
	type.each v3,,i3
		if v3.is_word(:inline) => type.vec_del(i3,2).vec_compact()
		if v3.is_word(:static) => type.vec_del(i3,2).vec_compact(); isstatic=:static
	ret={name: name, type: type.toks_c(), decltype: decltype, params: params}
	if with_body => ret.body=body
	if filename => ret.file=filename.file_nodir()
	if isstatic => ret.isstatic=isstatic
	return ret
}
static map* syn_funcs(map* mp,int with_body=0,char* filename=NULL){
	ret={}
	for int i=1; i<mp.map_len(); i+=2
		if mp[i].is_func_decl()
			fn=mp[i].syn_func(with_body,filename)
			if fn.name===:main => continue
			ret[fn.name]=fn
	return ret
}
static map* read_struct(map* toks){
	cols={}
	toks.toks_split(";").each v,,i
		if v.map_len()<2 => break
		hascurly=v.next_tok(0,"{")
		if hascurly
			name=v[hascurly+6]
			if name => cols[name]=v[hascurly+2].read_struct()
			else cols.map_merge(v[hascurly+2].read_struct())
		else
			cols[v.syn_var_name()]=v.syn_var_type()
	return cols		
}
map* c_structs(char* in){
	ret={}
	syn=in
		.x_map()
		.add_curly()
		.add_semicolon()
		.toks_syn(0)
	for int i=1; i<syn->len; i+=2
		if !syn[i][1].is_word("typedef struct union class enum") => continue
		toks=syn[i]
		hascurly=toks.next_tok(0,"{")	
		if !hascurly
			ret[toks.syn_var_name()]=toks.vec_sub(2).syn_var_type()
			continue
		istypedef=0
		from=1
		if toks[1]===:typedef	=> from+=2; istypedef=1
		name=toks.vec_sub(from,hascurly-1-from).toks_c()
		ret[name]=toks[hascurly+2].read_struct()
		if istypedef
			ret[toks[hascurly+6]]=ret[name]
	return ret
}
static map* x_funcs(char* in,int with_body=0,char* filename=NULL){
	return in.x_map()
		.add_curly(0)
		.add_semicolon(0)
		.toks_syn(0)
		.syn_funcs(with_body,filename)
}
static map* func_params(map* func) => return func.func_param().toks_split(",")
static map* func_param(map* func) => return func[func.next_tok(0,"(")+2]
static map* func_add_param(map* func,map* add){
	param=func.func_param()
	assert(param.is_vec())
	if param.map_len()
		if !(param.map_len()%2) => param.xadd(NULL)
		param.xadd(",")
	param.vec_merge(add)
	return func
}
static map* func_rename(map* func,char* name) => return func[1]=name
static char* func_name(map* func) => return func[1]
static map* map_assign(map* exp1,map* exp2){
	map* hasreturn=NULL
	if exp1.map_id(1)===:return => hasreturn=exp1.vec_sub(0,2); exp1.vec_del(0,2).vec_compact()
	params=exp1.func_params()
	funcname=exp1.func_name()===:map_val ? :add : :set
	if params[1][1]===:NULL
		params.vec_del(1,1).vec_compact()
		funcname=:vec_add
	exp1.syn_set_param(0,params.toks_join(","))
	exp1.func_add_param(exp2).func_rename(funcname)
	mp1=exp1.func_param()
	isvec=funcname===:vec_add ? 1 : 0
	while mp1.syn_is_call(0)
		if mp1.func_name()===:map_val => mp1.func_rename(:add_key)
		else if mp1.func_name()===:map_id => mp1.func_rename(:add_id)
		else break
		if isvec
			mp1.func_add_param([NULL,:Vector])
			isvec=0
		mp1=mp1.func_param()
	if hasreturn => exp1.vec_splice(0,0,hasreturn)
	return exp1
}
static map* call_count(map* toks,map* counter,char* infunc){
	if !toks => return counter
	for i=0; i<toks->len; i+=2
		name=toks.syn_is_call(i)
		if name!==infunc
			counter[name]=(counter[name].is_int()+1).int_var()
		if toks[i+1].is_map()
			toks[i+1].call_count(counter,infunc)
	return counter
}
static map* file_deadcode(char* file){
	funcs=file.file_read().x_funcs(1)
	ret={}
	funcs.each v,k,i
		v.body.call_count(ret,k)
	funcs.each v2,k2,i2
		if !ret[k2] => k2.px()
	return ret
}
static char* is_typecast(map* toks,int idx=0){
	if toks[idx+1]==="(" && toks[idx+3].is_var_decl() => return toks[idx+3].toks_c().str_trim()
	return NULL
}
static char* is_name(char* in){
	if !in.is_code() => return 0
	if in.is_word(:return) => return 0
	return in
}
static int expr_tail(map* toks,int idx=0,char* expr="."){
	idx++
	presid="= += -= /= *= %= ^= ||= &&= .= ? : || && == === !== != >= <= > < or and .. + - / * ++ -- ! -> ."
	expr_presid=expr.is_word(presid)
	while idx<toks.map_len()
		v=toks[idx].is_str()
		if v.is_name() && (toks[idx+2]===")"||toks[idx+2]==="]")
			idx+=8
		else if v==="("||v==="["
			idx+=6
		else if "\"'`".strchr(v[0])
			idx+=2
		else if v.is_name() || v.is_numeric()
			idx+=2
		else if expr_presid < v.is_word(presid)
			idx+=2
		else break
	return idx-1
}
static int expr_head(map* toks,int idx=0,char* expr="."){
	idx++
	presid="= += -= /= *= %= ^= ||= &&= .= ? : || && == === !== != >= <= > < or and .. + - / * ++ -- ! -> ."
	expr_presid=expr.is_word(presid)
	while idx>0
		v=toks[idx].is_str()
		if (v===")"||v==="]") && toks[idx-6].is_name()
			idx-=8
		else if v===")"||v==="]"
			idx-=6
		else if "\"'`".strchr(v[0])
			idx-=2
		else if v.is_name() || v.is_numeric()
			idx-=2
		else if expr_presid < v.is_word(presid)
			idx-=2
		else break
	return idx+1
}
static map* add_return(map* toks){
	return toks
}
static map* wrap_call(map* tok,char* func){
	return [NULL,func,NULL,"(",NULL,tok,NULL,")"]
}
static map* syn_expand_macro(map* syn,int idx){
	map* macro=macros()[syn[idx+1]]
//	"macro: $(syn[idx+1])".px()
	params=syn.syn_func_param().toks_split(",")
	if macro.params.map_len()!=params.map_len() => "Macro $(syn[idx]) takes $(macro.params.map_len()) parameters, $(params.map_len()) provided".fox_error()
	subs={}
	macro.params.each v2,,i2
		subs[v2]=params[i2].vec_del(0).vec_compact()
	return macro.body.vec_rdup().toks_replace(subs)
	expanded=macro.body.vec_rdup().toks_replace(subs)
	return syn.vec_splice(idx+1,7,expanded.vec_del(0).vec_compact())
//	return expanded.map_len()-7
}
static map* syn_is_macro(map* syn, int idx){
	return macros()[syn.syn_is_call(idx)]
}
static map* syn_set_param(map* syn,int idx=0,map* params){
	return syn[syn.next_tok(idx,"(")+2]=params
}
static map* syn_func_param(map* syn,int idx=0){
	return syn[syn.next_tok(idx,"(")+2]
}
static map* syn_func_body(map* syn){
	if !syn.next_tok(0,"{") => return NULL
	return syn[syn.next_tok(0,"{")+2]
}
static map* syn_remove_default(map* syn){
	params=syn.syn_func_param()
	if(!params) return syn
	indel=0
	hasdel=0
	start=0
	params.each v,,i
		if v==="="
			indel=1
			hasdel++
			params.vec_del(i,1)
		else if v==="..."
			if params[i-2].neq(",")
				params.vec_del(start+1,i-start-1)
		else if v===","
			start=i
			indel=0
		else if(indel) params.vec_del(i,1)
	if(hasdel) params.vec_compact()
	return syn
}

static char* assign_to_func(map* tok){
	return tok.syn_is_call(0)
}
static int next_tok(map* toks,int from,char* tok,int upto=0){
	if !toks => return 0
	for i=from; i<toks->len; i+=2
		if toks[i+1].is_word(tok) => return !upto || i<upto ? i+1 : 0
	return 0
}
static int syn_has(map* syn,char* words) => return syn.next_tok(0,words)
static char* syn_flow_name(map* syn) => return syn[1]
static int is_flow(map* syn){
	return syn[1].is_word("if while for switch do")
}
static map* syn_flow_condition(map* syn,int no=0){
	name=syn.syn_flow_name()
	// do:1 {:3 __:5 }:7 while:9 (:11 __:13 ):15
	// if:1 (:3 __:5 ):7 {:9 __:11 }:13
	// else:15 if:17 (:19 __:21 ):23 {:25 __:27 }:29
	// else:31 if:33 (:35 __:37 ):39 {:41 __:43 }:45
	// else:47 {:49 __:51 }:53
	if name===:do && !no => return syn[13]
	return syn[5+no*16].is_map()
}
static map* syn_flow_body(map* syn,int no=0){
	name=syn.syn_flow_name()
	// if:1 (:3 __:5 ):7 {:9 __:11 }:13
	// else:15 if:17 (:19 __:21 ):23 {:25 __:27 }:29
	// else:31 if:33 (:35 __:37 ):39 {:41 __:43 }:45
	// else:47 {:49 __:51 }:53
	if name===:do && !no => return syn[5]
	if !no => return syn[11]
	iselse=syn[11+(no-1)*16+8].is_map()
	return iselse ? iselse : syn[11+no*16]
}
static char* syn_is_call(map* syn, int idx){
	if syn[idx+1].is_code() && !syn[idx+1].is_keyword() && syn[idx+3]==="(" && syn[idx+7]===")"
		return syn[idx+1]
	return NULL
}
static char* syn_var_name(map* syn){
	idx=syn.next_tok(0,"= ; ,")
	return idx ? syn[idx-2] : syn[syn.map_len()-syn.map_len()%2-1]
}
static char* syn_var_type(map* syn){
	idx=syn.next_tok(0,"= ; ,")
	return idx ? syn.vec_sub(1,idx-4).toks_c() : syn.vec_sub(1,syn.map_len()-syn.map_len()%2-3).toks_c()
}
static int syn_assign_val(map* syn){
	return syn.next_tok(0,"=")+1
}
static int is_assign(map* syn) => return syn.next_tok(0,"=")
static int is_var_decl(map* syn){
	return syn[1].is_word("int long double float char void struct map static extern unsigned register mempage size_t time_t const FILE inline var")
}
static int is_func_decl(map* syn){
	idx=syn.next_tok(0,"(")
	if !idx-- => return 0
	if syn.next_tok(0,"=") => return 0
	if !syn[1].is_word("int long double float char void struct map static extern unsigned register mempage size_t time_t const FILE inline var")
		return 0
	if syn[idx+7]===";" => return 1
	if syn[idx+7]==="{" && syn[idx+13]===";" => return 1
	return 0
}
static char* to_c(void* val){
	if !val => return :NULL
	if val.is_i() => return val.is_int().int_str()
	if val.is_f() => return val.is_double().double_str()
	if val.is_str() => return val.str_quote()
	if val.is_map() => return val.json()
	assert(0)
	return :fox_error
}
static char* str_shorten(char* in,int max=40){
	if in.str_len()>max => return in.sub_str(0,max).."..."
	return in
}
static char* call_c(map* params,char* name){
	ret=[]
	params.each v,,i
		ret[]=v.to_c().str_shorten()
	return "$name($(ret.map_join(\", \")))"
}
map* source_funcs(map* infiles=NULL){
	if !infiles => return _globals.funcs
	map* mp={}	
	infiles.each v,,i
		map* mp3=''
		if v.str_end(".fox") => mp3=v.file_funcs(1)
		else mp3=v.file_funcs()
		"+ $(mp3.map_len()) <- $v".px()
		mp.map_merge(mp3)
	_globals.funcs=mp
	return _globals.funcs
}
map* file_funcs(char* filename,int withbody=0) => return filename.file_read().x_funcs(withbody,filename)
static void src(map* mp,int from=0,int len=0,char* msg=NULL){
	if !len => len=mp->len-from
	"$(mp.vec_sub(from,len).json())".px()
	if msg => "$msg ___________________________".px()
}
static map* structs(){
	return _globals.structs or _globals.reflect.structs
}
static map* macros(){
	return _globals.macros or _globals.reflect.macros
}
map* file_blocks(char* infile){
	toks=infile.file_read().str_tokenize("\n")
	ret=[]
	toks.each char* tok,,i=0 step 2
		if !tok => continue
		if tok[0]=='/' && (tok[1]=='/' || tok[1]=='*')
			ret[]={type: :comment, code: tok, space: toks[i+1] }
			continue
		head=tok.next_word(" \t\n")
		if head.is_word("typedef struct enum union class #include #pragma extern #define #if #ifdef #undef #else #endif #ifndef #line")
			ret[]={type: head, code: tok, space: toks[i+1] }
			continue
		if tok.str_chr('{') || tok.str_has('=>')
			ret[]={type: :func, code: tok, space: toks[i+1] }
			continue
		if tok.str_has('=>')
			ret[]={type: :linefunc, code: tok, space: toks[i+1] }
			continue
		ret[]={type: :global, code: tok, space: toks[i+1] }
	return ret
}
char* file_section(char* file, char* section){
	ret=''
	file.file_blocks().each rec
		if rec.type.is_word(section)
			ret.=rec.code..rec.space
	return ret
}
char* files_section(map* files, char* section){
	ret=''
	files.each file => ret.=file.file_section(section)
	return ret
}
static map* toks_syn(map* toks,int recurse=1){
	ret=[]
	line=[]
	for int i=0; i<toks.map_len()-1; i+=2
		v=toks[i+1]
		line.xadd(toks[i], v)
		if v===";"
			ret.xadd(NULL,line)
			line=[]
		if recurse && v.is_word(") else do") && toks[i+3]==="{"
			toks[i+5]= toks[i+5].toks_syn()
		else if v===:for => toks[i+5]= toks[i+5].toks_syn()
	if line.map_len() => ret.xadd(NULL,line)
	if toks.map_len()%2 => ret.xadd(NULL,[toks[toks.map_len()-1],NULL])
	return ret
}
char* increase_version(){
	if !is_file(".version.txt") => "0".write_file(".version.txt")
	return (".version.txt".file_read().atoi()+1).int_str().write_file(".version.txt")
}
static map* toks_replace(map* in,map* replace){
	in.each v,k,i
		if v.is_map()
			v.toks_replace(replace)
		else if v.is_str() && replace[v]
			in.vec_splice(i,1,replace[v]).vec_compact()
			i+=replace[v].map_len()+1
	return in
}
static map* toks_join(map* in, char* by=""){
	if !in => return NULL
	ret=in[0].vec_dup()
	assert(ret.is_vec())
	for i=1; i<in->len; i++
		if !(ret.map_len()%2) => ret.xadd(NULL)
		ret.xadd(by)
		ret.vec_merge(in[i])
	return ret
}
static map* expand_macros(map* mp,map* macros){
	if !mp => return NULL
	assert(mp.ptr_type()==Vector)
	old=0
	for i=1; i<mp->len; i+=2
		assert(i!=old)
		old=i
		v=mp[i]
		if v.is_map()
			v.expand_macros(macros)
		else if mp[i+2]==="(" && v.is_str() && macros[v] && !v.is_word(:End)
			map* macro=macros[mp[i]]
			params=mp[i+4].toks_split(",")
			if macro.params.map_len()!=params.map_len() => "Macro $(mp[i]) takes $(macro.params.map_len()) parameters, $(params.map_len()) provided".fox_error()
			subs={}
			macro.params.each v2,,i2
				subs[v2]=params[i2].vec_del(0).vec_compact()
			expanded=macro.body.vec_rdup().toks_replace(subs)
			mp.vec_splice(i,7,expanded.vec_del(0).vec_compact())
			i+=expanded.map_len()-7
	return mp
}
map* c_macros(char* in) => return in.x_map().toks_macros()
static map* toks_macros(map* mp){
	ret={}
	for i=0; i<mp.map_len(); i+=2
		if !mp[i].str_has("#define") => continue
		mp[i].str_split("\n").each line,,i2
			if !line.str_start("#define") => continue
			toks=line.drop_left("#define ").x_map()
			if toks[3]!=="(" => continue
			params=[]
			toks[5].map_split(",").each v,k,i3
				params[]=v[1]
			upto=9
			for ;upto<toks->len; upto+=2 => if toks[upto-1].is_str().str_has("\n") => break
			ret[toks[1]]= {name: toks[1], params: params, body: toks.vec_sub(8,upto-9)}
	return ret
}
static int is_inline_vector(map* toks,int idx){
	if !toks[idx].is_word("[ { ") => return 0
	pre=toks[idx-2].is_str()
	if pre===":"
		for int i=idx-4; i>=0; i-=2
			if toks[i]===:case => return 0
	if pre.is_word(") ]") => return 0
	if pre.is_code() && !pre.is_word(:return) => return 0
	if pre==="="
		type=toks.old_decl_type(idx-4)
		if type && !type.is_word("map* void* var") => return 0
	return toks[idx]==="[" ? Vector : Map
}
static map* string_operators(map* toks){
	for int i=0;i<=toks.map_len();i+=2
		if toks[i+1].is_map()
			toks[i+1].string_operators()
		else if toks[i+1]==='.='
			head=toks.expr_head(i-2,":")
			tail=toks.expr_tail(i+2,'.=')
			mid=toks.vec_sub(head+1,i-head-1)
			mid.vec_splice(0,0,[NULL]).vec_merge([NULL,","])
			mid.vec_merge(toks.vec_sub(i+2,tail-i-2)).vec_merge([NULL,","," ",:End])
			mid.each v2,k2,i2
				if v2==='..'
					mid[k2]=","
			mid=[:xcat,NULL,"(",NULL,mid,NULL,")"]
			toks.vec_splice(i+3,tail-i-3,mid)
			toks[i+1]="="
			i=head
		else if toks[i+1]===:and
			head=toks.expr_head(i-2,"and")
			tail=toks.expr_tail(i+2,"and")
			left=toks.vec_sub(head+1,i-head-1)
			right=toks.vec_sub(i+2,tail-i-2).string_operators()
			mid=["(",NULL,[NULL].vec_merge(left).vec_merge([toks[i],"?"]).vec_merge(right).vec_merge([" ",":"," ",:NULL]),NULL,")"]
			toks.vec_splice(head+1,tail-head-1,mid)
		else if toks[i+1]===:or
			head=toks.expr_head(i-2,"or")
			tail=toks.expr_tail(i+2,"or")
			left=toks.vec_sub(head+1,i-head-1)
			right=toks.vec_sub(i+2,tail-i-2).string_operators()
			mid=["(",NULL,[NULL].vec_merge(left).vec_merge([toks[i],"?"," "]).vec_merge(left).vec_merge([" ",":"]).vec_merge(right),NULL,")"]
			toks.vec_splice(head+1,tail-head-1,mid)
		else if toks[i+1]==="||="
			head=toks.expr_head(i-2,":")
			tail=toks.expr_tail(i+2,"||=")
			left=toks.vec_sub(head+1,i-head-1)
			right=toks.vec_sub(i+2,tail-i-2)
			mid=["if",NULL,"(",NULL,[NULL,"!",NULL,"(",NULL,[NULL].vec_merge(left),NULL,")"],NULL,")",NULL,"{",toks[i],[NULL,[NULL].vec_merge(left).vec_merge([NULL,"="]).vec_merge(right).vec_merge([NULL,";"])],NULL,"}"]
			toks.vec_splice(head+1,tail-head-1,mid)
		else if toks[i+1]==="&&="
			head=toks.expr_head(i-2,":")
			tail=toks.expr_tail(i+2,"&&=")
			left=toks.vec_sub(head+1,i-head-1)
			right=toks.vec_sub(i+2,tail-i-2)
			mid=["if",NULL,"(",NULL,[NULL].vec_merge(left),NULL,")",NULL,"{",toks[i],[NULL,[NULL].vec_merge(left).vec_merge([NULL,"="]).vec_merge(right).vec_merge([NULL,";"])],NULL,"}"]
			toks.vec_splice(head+1,tail-head-1,mid)
		else if toks[i+1]==='..'
			head=toks.expr_head(i-2,"<")
			tail=toks.expr_tail(i+2,"<")
			mid=toks.vec_sub(head+1,tail-head-1).vec_splice(0,0,[NULL]).vec_merge([NULL,","," ",:End])
			mid.each v2,k2,i2
				if v2==='..'
					mid[k2]=","
			mid=[:xstr,NULL,"(",NULL,mid,NULL,")"]
			toks.vec_splice(head+1,tail-head-1,mid)
			i=head
		else if toks[i+1]==='==='||toks[i+1]==='!=='
			head=toks.expr_head(i-2,'==')
			tail=toks.expr_tail(i+2,'==')
			mid=toks.vec_sub(head+1,i-head-1).xadd(NULL,",").vec_merge(toks.vec_sub(i+2,tail-i-2)).vec_splice(0,0,[NULL])
			if toks[i+1]==='!==' => mid=["!",NULL,:str_eq,NULL,"(",NULL,mid,NULL,")"]
			else mid=[:str_eq,NULL,"(",NULL,mid,NULL,")"]
			toks.vec_splice(head+1,tail-head-1,mid)
			i=head
	return toks
}
static map* inline_vectors(map* toks){
	if !toks.map_len() => return toks
	for int idx=1;idx<=toks->len;idx+=2
		if toks[idx].is_map()
			toks[idx].inline_vectors()
			continue
		type=toks.is_inline_vector(idx)
		if !type => continue
		map* body=toks[idx+2].is_map()
		if !body => continue
		if type==Map && body[1]==="0" => continue
		body.inline_vectors()
		toks[idx]="("
		toks[idx+4]=")"
		funcname=:xmap
		if type==Vector => funcname=:xvec
		if body->len<2 => funcname= type==Vector ? :new_vec : :new_map
		toks.vec_splice(idx,0,[funcname,NULL])
		skip=0
		for int idx2=1;idx2<=body->len;idx2+=2
			if body[idx2]==="?" => skip++
			if body[idx2]===":"
				if !skip
					if body[idx2-2].is_code()
						if body[idx2-2].is_word("NULL null")
							body[idx2-2]=:NULL
						else
							body[idx2-2]=body[idx2-2].str_quote()
					if idx2>4 && body[idx2-2]!==")" && body[idx2-4]!==","
						if body[idx2-4]===";" => body[idx2-4]=","
						else
							body.vec_splice(idx2-3,0,[NULL,","])
							idx2+=2
					else if idx2>8 && body[idx2-2]===")" && body[idx2-8]!==","
						if body[idx2-8]===";" => body[idx2-8]=","
						else
							body.vec_splice(idx2-7,0,[NULL,","])
							idx2+=2
					body[idx2]=","
				if skip => skip--
		if body[body->len-body->len%2-1]===";"
			body.vec_del(body->len-body->len%2-2,2).vec_compact()
		idx+=6
		if toks.requires_semicolon(idx+1) => toks.vec_splice(idx+2-1,0,[NULL,";"])
	return toks
}
static map* file_map(char* filename) => return filename.file_read().data_map()
map* data_map(char* in) => return data_map2(&in)
static map* data_map2(char** in,int level=0){
	if !in||!*in||!**in => return NULL
	str=*in
	ret={}
	last=''
	while *str
		assert(last!=str)
		last=str
		tabstart=str.skip_over("\n\r")
		if str.str_start("//") => str=skip_upto(str,"\n\r"); continue
		keystart=tabstart.skip_over(" \t")
		keyend=keystart.skip_code(" \r\n\t")
		if keyend==keystart => str=keyend; continue
		if keystart-tabstart<level => break
		str=keyend
		key=keystart.sub_str(0,keyend-keystart).data_unquote()
		valstart=keyend.skip_over(" \t")
		valend=valstart.skip_upto("\n\r")
		str=valend
		if valend==valstart
			submap=data_map2(&str,level+1)
			if submap => ret[key]=submap
			else ret[key]=NULL
		else
			val=valstart.sub_str(0,valend-valstart)
			if val[0]=='-' && " \t".str_chr(val[1]) => ret[key]=val.prop_map(key)
			else ret[key]=val.data_unquote()
	if ret.map_len()
		*in=str
		return ret
	return NULL	
}
static char* skip_code(char* in,char* terminator){
	while *in
		if "({[".str_chr(*in) => in=in.skip_paren(); continue
		if "\"'`".str_chr(*in) => in=in.skip_quote(); continue
		if terminator.str_chr(*in) => break
		in++
	return in
}
static char* skip_upto(char* in,char* chars=" \t\n\r"){
	while(*in && !chars.strchr(*in)) in++
	return in
}
static void* data_unquote(char* in){
	if !in || !in.str_len() => return NULL
	if "\"'`".str_chr(*in) => return in.str_unquote()
	if *in=='=' => return in //return in.sub_str(1).eval()
	if in.str_start("---") => return in.sub_str(3,-3)
	if *in=='{' => return in.sub_str(1,-1).prop_map()
	if *in=='[' => return in.sub_str(1,-1).prop_vec()
	return in
}
static map* prop_vec(char* in){
	ret=in.split_by(',')
	ret.each val,idx
		ret[idx]=val.data_unquote()
	return ret
}
static map* prop_map(char* in,char* name=NULL){
	ret={}
	toks=in.split_by(',')
	toks.each val,, idx
		val=val.split_by(' ',2)
		if !val.map_len() => continue
		if idx==0 && val[0]==="-"
			if name => ret.name=name
			val[0]=:type
		ret[val[0].data_unquote()]=val[1].data_unquote()
	return ret
}
char* callfunc_c(map* funcs){
	ret="function calls\n"
	fdups={}
	funcs.each v,k,i2
		if fdups[v.name] => continue
		fdups[v.name]=1
		if k===:args_map => continue
		if v.name.is_word("main run") => continue
		str_params=v.func_ccall()
		if(!str_params)
			continue
		//pp1
		ret.="\t\tcase %p: { %s break; }\n".mstr(v.name.str_hash(),str_params)
	return ret
}
static char* func_ccall(map* fn){
	ret=''
	preproc=''
	isvariadic=0
	fn.params.each v,k,i
		char* def=v.default
		v=v.type
		v=v.drop_left(:const\ )
		v=v.drop_left(:unsigned\ )
		pre=''
		post=''
		mid="v.map_id($i)"
		if k==="..."
			mtype=''
			if fn.type===:void || fn.type.str_end("*") => mtype=:ptr
			else if fn.type===:int => mtype=:int
			else if fn.type===:double => mtype=:double
			else return NULL
			isvariadic=1
			ret="call_variadic_$mtype(v,$(fn.name),\"$(fn.name)\")"
			break
		else if v==="char*" => post=".is_str()"
		else if v==="char**" => preproc.="char* p$(k)_$(fn.name)=v.map_id($i).is_str(); "; mid="&p$(k)_$(fn.name)"
		else if v==="map*" => post=".is_map()"
		else if v.is_word("int long size_t time_t") || v==="long long" => post=".to_int()"
		else if v===:char
			post=".is_str() ? $mid.is_str()[0] : $mid.to_int())"
			pre="("
		else if v.is_word("double float") => post=".to_double()"
		else if !v.str_end("*")
			return NULL
		if def => ret.="v->len>=$i ? $pre$mid$post : $(def.x_c().sub_str(0,-1)),"
		else => ret.="$pre$mid$post,"
	char* postproc=''
	if fn.type.is_word("int long long size_t time_t char") => postproc=".int_var()"; preproc.='return '
	else if fn.type.is_word("double float") => postproc=".double_var()"; preproc.='return '
	else if fn.type===:void
		postproc.="; return NULL"
	else if(!fn.type.is_word("void* map* char*")) return NULL
	else preproc.='return '
	if isvariadic => return "$preproc$ret$postproc".x_c()
	return "$preproc$(fn.name)($(ret.sub_str(0,-1).null_str()))$postproc".x_c()
	//pp1
}
char* fox_c(char* infile, char* outfile=NULL) => return infile.file_read().x_c().write_file(outfile)
char* x_c(char* in) => return in.x_toks().toks_c()
static map* type_convert(map* tok,char* outtype,map* env,map* fs,map* fn){
	if !outtype => return tok
	intype=tok.expr_type(0,0,env,fs)	
	if !intype => return tok
	if intype===outtype => return tok
	if intype.is_word("int double long long") && outtype.str_start(intype) && outtype[intype.str_len()]=='*' && !outtype[intype.str_len()+1]
		return tok.vec_splice(1,0,["&",NULL])
	if intype.is_word("int long long size_t")
		if outtype==="void*" => return tok.wrap_call(:int_var)
		else if outtype==="char*" => return tok.wrap_call(:int_str)
	else if intype==="void*"
		if outtype===:double => return tok.wrap_call(:to_double)
	else if intype===:double
		if outtype==="void*" => return tok.wrap_call(:double_var)
		else if outtype==="char*" => return tok.wrap_call(:double_str)
	else if intype==="map*"
		if outtype==="char*" => return tok.wrap_call(:to_str)
	else if intype==="char*"
		if outtype===:int => return tok.wrap_call(:stoi)
		else if outtype==="char**"
			return tok.vec_splice(1,0,["&",NULL])
	else if intype==="char**"
		if outtype==="char*" => return tok.vec_splice(1,0,["*",NULL])
	return tok
}
static map* param_c(map* params,map* env,map* fs,map* fn){
	assert(fn)
	if !params => return NULL
	xparam=params.toks_split(",")
	cparam=[]
	sig=fn.params
	sig.each p,name,i
		if name==="..."
			for int idx=i; idx<xparam->len; idx++
				if xparam[idx][1]===:End => break
				cparam[]=xparam[idx].type_convert(p.type,env,fs,fn)
			if cparam[cparam.map_len()-1][1].neq(:End)
				if !cparam[cparam.map_len()-1][1] => cparam[cparam.map_len()-1][1]=:End
				else
					endmark=cparam.map_len() ? " End" : :End
					cparam[]=endmark.x_map()
			break
		else if xparam[i].map_len()<2
			if !p.default => break
			cparam[]=p.default.x_toks()[1].vec_del(-2,0).vec_compact() //x_map().colon_str().dot_key().str_dollars()
		else 
//			xparam[i].dx(:IN)
//			xparam[i].expr_type(0,0,env,fs).dx(:INTYPE)
//			p.type.dx(:OUT)
//			xparam[i].type_convert(p.type,env,fs,fn).toks_c().dx(:CONVERTED)
//			"^^^^^^^^^^^^".px()
			cparam[]=xparam[i].type_convert(p.type,env,fs,fn)
	ret=cparam.toks_join(",")
	return ret
}
static char* head_type(map* toks, int idx, int upto, map* env,map* fs){
	head=toks.expr_head(idx)
	return toks.expr_type(head, upto, env, fs)
}
char* help(char* func=''){
	if func
		return funcs()[func].func_cdecl()
	return funcs().funcs_cdecl()
}
char* expr_type(map* toks,int idx=0,int upto=0,map* env={:_globals : "map*"},map* fs=NULL){
	void* v=toks[idx+1]
	if v.is_map() => return v.expr_type(0,upto,env,fs)
	w=v.is_str()
	if !w => return NULL
	assert(w.is_str() && w.str_len())
	if toks.next_tok(idx,"?",upto)
		return toks.expr_type(toks.next_tok(idx,"?")+1,upto,env,fs)
//	else if toks.next_tok(idx,"/",upto) => return :int
	else if toks[idx+3]==="("
		name=toks[idx+1].is_str()
		if fs[name] => return fs[name].type
		return funcs()[name].type
	else if w.is_word("++ --") => return toks.expr_type(idx+2,upto,env,fs)
	else if *w=='"' => return "char*"
	else if *w=='\'' && w[1]=='\'' => return "char*"
	else if *w=='\'' => return :char
	else if *w>='0' && *w<='9' || *w=='-' || *w=='+' => return w.strchr('.') ? :double : :int
	else if toks.is_typecast(idx) => return toks.is_typecast(idx)
	else if w==="(" => return toks[idx+3].expr_type(0,upto,env,fs)
	else if w==="*" => return toks.expr_type(idx+2,upto,env,fs).sub_str(0,-1)
	else if w==="&" => return toks.expr_type(idx+2,upto,env,fs).str_dup().."*"
	else if w===:NULL => return "void*"
	else if env[w]
		if toks.next_tok(idx,"-",upto) && toks.expr_type(toks.next_tok(idx,"-",upto)+1,upto,env,fs).is_word("char* void* map*")
			return :int
		char* ret=env[w]	
		if !upto => upto=toks->len
		map* structtype=NULL
		for int i=idx+3; i<upto; i+=2
			v=toks[i]
			if v.is_word(". ->")
				structtype=structs()[ret.str_trim("*")]
			else if structtype && v.is_code() && !toks.syn_is_call(i) && structtype[v]
				ret=structtype[v]
			else if v==="[" && ret.fox_at(-1)=='*'
				ret=ret.sub_str(0,-1)
				i+=4
			else if v==="-"
				if ret===:int => return ret
				rest=toks.expr_type(i+1,upto,env,fs)
				if rest.fox_at(-1)=='*' => return :int
				return ret
			else return ret
		return ret
	return NULL
}
map* x_toks(char* in,int is_script=0){
	if !in => return NULL
	return in.x_map()
		.colon_str()
		.dot_key()
		.str_dollars()
		.add_curly()
		.force_curly()
		.add_semicolon()
		.expand_main()
		.dot_func()
		.dot_each()
		.toks_syn()
		.heredoc_str()
		.string_operators()
		.inline_vectors()
		.auto_types(:c, is_script)
		.single_quotes()
}
static map* auto_types(map* toks,char* context=:c,int is_script=0,map* env={},map* fns={},map* func=NULL,int idx=0){
	temp=0
	if !toks => return toks
	if context===:c
		env={:_globals : "map*"}
		for i=0; i<toks->len; i+=2
			void* tok=toks[i+1]
			if tok.is_func_decl()
				fn=tok.syn_func(1)
				fns[fn.name]=fn
				tok.syn_remove_default()
		fns.each fn,name,i
			fenv=env.map_dup()	
			fn.params.each op,param,i2
				fenv[param]=op.type
			fn.body.add_return().auto_types(:body,is_script,fenv,fns,fn)
			if is_script
				if fn.body => _globals.userfuncs[fn.name]=fn.body
				_globals.reflect.funcs[fn.name]=fn.map_del_key(:body)
		return toks.auto_types(:body,is_script,env,fns)
	else if context===:body
		for int j=0; j<toks->len; j+=2
			void* tok=toks[j+1]
			if tok.is_func_decl()
				continue
			else if tok.syn_is_macro(0)
				expanded=tok.vec_dup().syn_expand_macro(0).toks_syn()
				map* last=expanded[expanded.map_len()-1]
				expanded.vec_del(-2).vec_compact().auto_types(:body,is_script,env,fns,func)
				last.vec_merge(tok.vec_sub(8)).auto_types(:syn,is_script,env,fns,func)
				if is_script
					toks.vec_splice(j+1,1,expanded)
			else tok.auto_types(:syn,is_script,env,fns,func)
		return toks
	else if context===:syn
		if toks.is_var_decl()
			type=toks.syn_var_type()
			name=toks.syn_var_name()
			env[name]=type
			toks.auto_types(:expr,is_script,env,fns,func,toks.syn_assign_val())
		else if toks.is_flow()
			type=toks.syn_flow_name()
			if type===:for
				env=env.map_dup()
				toks.syn_flow_condition()[1].auto_types(:syn,is_script,env,fns)
			int i=0
			map* body=NULL
			while (body=toks.syn_flow_condition(i++))
				body.auto_types(:expr,is_script,env.map_dup(),fns,func)
			i=0
			while (body=toks.syn_flow_body(i++))
				body.auto_types(:body,is_script,env.map_dup(),fns,func)
		else if toks.is_assign()
			toks.auto_types(:expr,is_script,env,fns,func)
			if toks.syn_is_call(toks.map_id(1)===:return ? 2 : 0).is_word("map_val map_id")
				toks.auto_types(:expr,is_script,env,fns,func)
				from=toks.syn_assign_val()
				upto=toks.next_tok(toks.syn_assign_val(),"; =")
				len=0
				if upto => len=upto-from-1
				val=toks.vec_slice(from,len)
				toks.vec_compact().vec_del(toks.next_tok(0,"=")-1,2).vec_compact()
				toks.map_assign(val).auto_types(:expr,is_script,env,fns,func)
				return toks
			name=toks.syn_var_name()
			type=toks.syn_var_type()
			if *name!='_' && !env[name] && !type.str_len()
				type=toks.expr_type(toks.syn_assign_val(),0,env,fns)
				if type
					toks.vec_splice(1,0,"$type ".x_map().vec_del(0).vec_compact())
					env[name]=type
				else
					"$(func.name)(): unknown void* $name".px()
			toks.auto_types(:expr,is_script,env,fns,func,toks.syn_assign_val())
		else
			toks.auto_types(:expr,is_script,env,fns,func)
		return toks
	else if context===:expr
		int head=idx
		for int i=idx; i<toks->len; i+=2
			if toks[i+1].is_map()
				toks[i+1].auto_types(:expr,is_script,env,fns,func)
			else if toks.syn_is_call(i)
				toks[i+5].auto_types(:expr,is_script,env,fns,func)
				name=toks.syn_is_call(i)
				if name===:args_map
					subs="xmap("
					func.params.each ,k2,i2
						subs=subs.xcat(":",k2,",",k2,",")
					mp4="$subs End)".x_map().colon_str().vec_del(0).vec_compact()
					toks.vec_splice(i+1,7,mp4)
				else
					params=toks.syn_func_param(i)
					map* fn=fns[name]
					if !fn => fn=funcs()[name]
					if fn
						params=params.param_c(env,fns,fn)
					toks.syn_set_param(i,params)
			else if toks[i+1]==="[" && toks.head_type(i-2,i,env,fns).is_word("map* void* var") && toks.is_typecast(head).neq("void*") && 1
				name=toks[i+3]
				if !name.map_len() => name=[NULL,:NULL]
				head=toks.expr_head(i-2)
				mid=toks.vec_sub(head+1,i-head-1).vec_splice(0,0,[NULL]).xadd(NULL,",").vec_merge(name)
				callfunc=name.expr_type(0,0,env,fns)===:int ? :map_id : :map_val
				toks.vec_splice(head+1,i+5-head,[callfunc,NULL,"(",NULL,mid,NULL,")"])
				i=head
			else if toks[i+1]==="." && toks[i+3].is_name() && toks.expr_head(i-2)<i
				head=toks.expr_head(i-2)
				if head==i => "Can't find header for $(toks.json()) @ $i".fox_error()
				if toks.syn_is_call(i+2).is_word("each")
					mid=toks.vec_sub(head+1,i-head-1).vec_splice(0,0,[NULL])
					params=toks.syn_func_param(i+2).toks_split(",")
					if mid.syn_is_call(0)
						temp++
						varname=:map_..temp.int_str()
						toks.syn_set_param(i+2,params.vec_splice(0,0,[[NULL,varname]]).toks_join(","))
						toks.vec_splice(head+1,i-head+2,"map* $varname=".x_map().vec_splice(0,1,NULL).vec_merge(mid).vec_merge([NULL,";"," "]))
					else
						params=params.vec_splice(0,0,[mid]).toks_join(",")
						toks.syn_set_param(i+2,params)
						toks.vec_del(head+1,i-head+2)
						toks.vec_compact()
					i=head
				else if toks.syn_is_call(i+2)
					mid=toks.vec_sub(head+1,i-head-1).vec_splice(0,0,[NULL])
					toks.vec_del(head+1,i-head+2)
					params=toks.syn_func_param(i+2).toks_split(",").vec_splice(0,0,[mid])
 					params=params.toks_join(",")
					toks.syn_set_param(i+2,params)
					toks.vec_compact()
					i=head-2
				else if toks.expr_type(head,i,env,fns).is_word("map* void* var") && toks.is_typecast(head).neq("void*")
					name=toks[i+3]
					mid=toks.vec_sub(head+1,i-head-1).xadd(NULL,",",NULL,name.str_unquote().str_quote()).vec_splice(0,0,[NULL])
					toks.vec_splice(head+1,i+3-head,[:map_val,NULL,"(",NULL,mid,NULL,")"])
					i=head
		return toks					
	return toks
}
map* file_callmap(char* filename) => return filename.file_funcs(1).func_depends(filename)
static map* func_depend(map* mp,map* ret={}){
	for int i=0; i<mp.map_len(); i+=2
		if mp[i+1].is_map() => mp[i+1].func_depend(ret); continue
		name=mp.syn_is_call(i)
		if name => ret[name]=funcs()[name].file
	return ret
}
map* depends(char* filename){
	ret={}
	map* ref=_globals.reflect
	ref.depends.each funcs, name
//		funcs.px()
		if ref.funcs[name].file===filename
			continue
		funcs.each file, name1
			if file!==filename => continue
			"$(ref.funcs[name].file) $name $name1 $filename".px()
			ret[ref.funcs[name].file]=ref.funcs[name].file
	return ret
}
map* file_depends(char* filename, char* ...){
	files={}
	files[filename]=filename.file_funcs(1)
	filenames=[]
	va_list args
	args.va_start(filename)
	while 1
		void* val=args.va_arg(void*)
		if val==End => break
		filenames[]=val
	args.va_end()
	filenames.each name
		files[name]=name.file_funcs(1)
	funcs={}
	files[filename].each ,name
		name.func_depend_recursive(filename,funcs,files)
	return funcs
}
static map* func_depends(map* mp,char* filename){
	ret={}
	mp.each fn,name
		fn.body.func_depend().each val,key => "$filename $name $key $val".px()
	return ret
}
int utests(char* test=NULL,char* file="utests.map"){
	mp=file.file_vec()
	errs=0
	runs=0
	for int i=0; i<mp.map_len(); i+=3
		if test && !mp[i].str_has(test) => continue
		runs++
		"Running: %20s\r".printf(mp[i])
		stdout.fflush()
		errs+=mp[i+1].eval().utest(mp[i+2],mp[i+1],mp[i])
	passed=runs-errs
	"\n$passed/$runs tests passed.".px()
	return errs
}
map* funcs(){
	return _globals.funcs or _globals.reflect.funcs
}
void* fox_run(char* in){
	int halt=0
	return in.x_toks(1).fox_eval({args: _globals.args},&halt)
}
static void* fox_eval(map* mp,map* env,int* halt){
	if !mp => return NULL
	assert(mp.ptr_type()==Vector)
	enum {HBreak=1, HReturn, HContinue};
	void* v=mp[1]
	void* ret=NULL
	if v.is_map()
		mp.each v3,k3,i3
			ret=v3.fox_eval(env,halt)
			if *halt => return ret
		return ret
	if v===:if
		idx=5
		while 1
			if mp[idx].eval_toks(env).is_true()
				return mp[idx+6].fox_eval(env,halt)
			else if mp[idx+10]===:else
				if mp[idx+12]===:if => idx+=16
				else return mp[idx+14].fox_eval(env,halt)
			else
				return NULL
	else if v===:while
		while mp[5].eval_toks(env).is_true()
			ret=mp[11].fox_eval(env,halt)
			if *halt==HContinue => *halt=0
			else if *halt==HBreak => *halt=0; break
			else if *halt => break
		return ret
	else if v===:for
		map* conds=mp[5]
		for conds[1].eval_toks(env); conds[3].eval_toks(env).is_true(); conds[5].eval_toks(env)
			ret=mp[11].fox_eval(env,halt)
			if *halt==HContinue => *halt=0
			else if *halt==HBreak => *halt=0; break
			else if *halt => break
		return ret
	else if v===:return
		*halt=HReturn
		return mp.eval_toks(env)
	else if v===:break
		*halt=HBreak
	else if v===:continue
		*halt=HContinue
	else if mp.is_func_decl()
		return ret
	else
		return mp.eval_toks(env)
	return ret
}
static void* eval_toks(map* mp,map* env){
	int idx=1
	return mp.eval_expr(&idx,env,0)
}
static void* eval_expr(map* mp,int* idx,map* env,int level){
	void* last=NULL
	*idx=mp.eval_expr_cont(*idx,env,&last,level)
	return last
}
static void* binary_op(void* left, char oper, void* right){
	if left.is_f()||right.is_f()
		double a=left.is_double()
		double b=right.is_double()
		if oper=='+' => return (a+b).double_var()
		if oper=='-' => return (a-b).double_var()
		if oper=='/' => return (a/b).double_var()
		if oper=='*' => return (a*b).double_var()
		return 0.double_var()
		"Unknown operator $oper".fox_error()
	long long a=left.is_int()
	long long b=right.is_int()
	if oper=='+' => return (a+b).int_var()
	if oper=='-' => return (a-b).int_var()
	if oper=='/' => return (a/b).int_var()
	if oper=='*' => return (a*b).int_var()
	"Unknown operator $oper".fox_error()
	return NULL
}
static int is_true(void* val){
	if !val => return 0
	if val.is_i() => return val.is_int()
	if val.is_f() => return val.is_double()
	if val.is_map() => return val.map_len()
	if val.is_str() => return val.str_len()
	return 1
}
char* func_cdecl(map* fn,int show_default=1){
	ret2=""
	fn.params.each param,name,i2
		s=param.type.str_join(" ",name)
		if name==="..." => s=name
		if show_default => s=s.str_join("=",param.default)
		ret2=ret2.str_join(", ",s)
	file=''
	if fn.file => file="//$(fn.file)"
	return "$(fn.decltype) $(fn.name)($ret2); $file"
}
void* eval(char* in,map* env=NULL){
	return in.x_toks().eval_toks(env)
}
static int eval_expr_cont(map* mp,int idx,map* env,void** last,int level){
	if !mp => return idx
	void* ret=*last
	if(!level) level=100
	for ;idx<mp->len;idx+=2
		void* val=mp[idx];	
		if !val => continue //abnormal
		if val.is_map() => ret=val.eval_toks(env); continue
		else if val.is_num() => :int.px(); ret=val; continue
		else if val.is_numeric()
			if val.strchr('.')
				v2=0.0
				sscanf(val,"%lf",&v2)
				ret=v2.double_var()
			else
				long long v2=0
				sscanf(val,"%lld",&v2)
				ret=v2.int_var()
//				ret=atoi(val).int_var()
			continue
		else if val.fox_at(0)=='"'
			ret=val.str_unquote()
			while mp[idx+2].is_str().fox_at(0)=='"'
				ret.=mp[idx+2].str_unquote()
				idx+=2
			continue
		else if val==="&"
			name=mp[idx+2]
			if !name.is_code() => "operator& on a non variable $name".fox_error(1)
			idx1=env.map_has_key(name)
			if !idx1 => "variable $name doesn't exist".fox_error(1)
			ret=&(env->pairs[idx1-1].val)
			idx+=2
		else if val==="(" => ret=mp[idx+2].eval_toks(env); idx+=4; continue
		else if val===:End
			ret=End
			idx+=2
		else if val.is_code()
			if val===:NULL
				ret=NULL
			else if val===:_globals
				ret=_globals
			else if mp[idx+2]==="("
				params=mp[idx+4].map_split(",",0)
				params.each v,,i => params[i]=v.eval_toks(env)
				ret=params.call_func(val,env)
				idx+=6
			else if env.map_has_key(:_) && env._.map_has_key(val)
				ret=env._[val]
			else if mp[idx+2]==="="
				idx+=4
				ret=mp.eval_expr(&idx,env,6)
				env[val]=ret
			else if mp[idx+2]==="++"
				idx+=2
				env[val]=binary_op(env[val],'+',1)
			else if mp[idx+2]==="--"
				idx+=2
				env[val]=binary_op(env[val],'-',1)
			else if mp[idx+2]==="+="
				idx+=4
				env[val]=binary_op(env[val],'+',mp.eval_expr(&idx,env,6))
			else if mp[idx+2]==="-="
				idx+=4
				env[val]=binary_op(env[val],'-',mp.eval_expr(&idx,env,6))
			else if mp[idx+2]==="*="
				idx+=4
				env[val]=binary_op(env[val],'*',mp.eval_expr(&idx,env,6))
			else if mp[idx+2]==="/="
				idx+=4
				env[val]=binary_op(env[val],'/',mp.eval_expr(&idx,env,6))
			else
				ret=env[val]
			continue
		else if val==="." => if(ret.is_map()) ret=ret[mp[idx+=2-1]]; continue
		else if val==="!"
			idx+=2
			ret=mp.eval_expr(&idx,env,0)
			ret = (ret.is_i() ? !ret.is_int() : !ret).int_var()
			continue

		int clevel=1
		if level<=clevel => idx-=2; break
		if val==="/" => idx+=2; ret=binary_op(ret,'/',mp.eval_expr(&idx,env,clevel)); continue
		else if val==="*" => idx+=2; ret=binary_op(ret,'*',mp.eval_expr(&idx,env,clevel)); continue

		clevel++
		if level<=clevel => idx-=2; break
		if val==="-" => idx+=2; ret=binary_op(ret,'-',mp.eval_expr(&idx,env,clevel)); continue
		else if val==="+" => idx+=2; ret=binary_op(ret,'+',mp.eval_expr(&idx,env,clevel)); continue


		clevel++
		if level<=clevel => idx-=2; break
		if val.is_word("== !=")
			idx+=2
			void* rest=mp.eval_expr(&idx,env,clevel)
			if ret.is_i() => ret=(ret.is_int()==rest.to_int()).int_var()
			else if ret.is_str() => ret=(ret===rest).int_var()
			else ret=NULL
			if val==="!=" => ret=(!ret.is_int()).int_var()
			continue
		else if val.is_word("> < >= <=")
			idx+=2
			int val1=ret.is_int()
			int val2=mp.eval_expr(&idx,env,clevel).is_int()
			if val===">" => val1=val1>val2
			else if val==="<" => val1=val1<val2
			else if val==="<=" => val1=val1<=val2
			else if val===">=" => val1=val1>=val2
			ret=val1.int_var()
			continue

		clevel++
		if level<=clevel => idx-=2; break
		if val==="&&"
			idx+=2
			if ret.is_true() => ret=mp.eval_expr(&idx,env,clevel)
			else
				while idx<mp->len-2
					if mp[idx].is_word("&& || ? :") => idx-=2; break
					idx+=2
			continue
		
		clevel++
		if(level<=clevel){ idx-=2; break; }
		if val==="||"
			idx+=2
			if ret.is_true() => break
			else ret=mp.eval_expr(&idx,env,clevel)
			continue

		clevel++
		if(level<=clevel){ idx-=2; break; }
		if val==="?"
			idx+=2
			if ret.is_true()
				ret=mp.eval_expr(&idx,env,clevel)
				break
			else
				while idx<mp->len && mp[idx]!==":" => idx+=2
				continue
		if val===":"
			break

		clevel++
		if(level<=clevel){ idx-=2; break; }
		if val==="="
			idx+=2
			if !ret.is_str() => "eval() in name=value name should be a valid name".fox_error()
			void* val=mp.eval_expr(&idx,env,clevel)
			env[ret]=val
			ret=val
			continue

	*last=ret
	return idx
}
void* data_exec(void* data,map* env=NULL){
	if !data => return NULL
	if data.is_str() => return data	
	if !data.is_map() => return data.to_str()
	char* func=data[0]
	return data.map_del(0).vec_compact().call_func(func,env)
}
void* call_func(map* params,char* name,map* env=NULL){
	params=params.eval_params(name,env)
	if name.str_start(:php_) => return params.call_php(name.sub_str(5))
	map* user=_globals.userfuncs[name]
	void* ret=NULL
	if user
		int halt=0
		ret=user.fox_eval(params,&halt)
	else
		ret=params.invoke(name)
	return ret
}
static map* ping_map(map* in) => return in
map* func_depend_recursive(char* func, char* file, map* funcs, map* files){
	if funcs[func] => return funcs
	funcs[func]=file
	if !file
		"-- $func -- --".px()
		return funcs
	if !files[file] => files[file]=file.file_funcs(1)
	mp=files[file]
	mp=mp[func].body.func_depend()
	mp.each ffile, fname
		if funcs[fname] => continue
		if !ffile
			files.each fncs, fs
				if fncs[fname] => ffile=fs; break
		"$file $func $fname $ffile".px()
		fname.func_depend_recursive(ffile, funcs, files)
	return funcs
}
//TODO: merge with _ptr defined bellow.
int call_variadic_int(map* mp,void* fp,char* name){
	int(*ptr)(void* param1,...)=fp
	if !mp => return ptr(End)
	len=mp.map_len()
	if mp[mp->len-1]==(void*)End => len--
	if len==0 => return ptr(End)
	if len==1 => return ptr(mp[0],End)
	if len==2 => return ptr(mp[0],mp[1],End)
	if len==3 => return ptr(mp[0],mp[1],mp[2],End)
	if len==4 => return ptr(mp[0],mp[1],mp[2],mp[3],End)
	if len==5 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],End)
	if len==6 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],End)
	if len==7 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],End)
	if len==8 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],End)
	if len==9 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],End)
	if len==10 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],End)
	if len==11 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],End)
	if len==12 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],End)
	if len==13 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],End)
	if len==14 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],End)
	if len==15 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],End)
	if len==16 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],End)
	if len==17 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],End)
	if len==18 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],End)
	if len==19 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],End)
	if len==20 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],End)
	if len==21 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],End)
	if len==22 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],End)
	if len==23 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],End)
	if len==24 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],End)
	if len==25 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],End)
	if len==26 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],End)
	if len==27 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],End)
	if len==28 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],End)
	if len==29 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],End)
	if len==30 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],mp[29],End)
	if len==31 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],mp[29],mp[30],End)
	if len==32 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],mp[29],mp[30],mp[31],End)
	"Only 32 parameters supported in call to function $name sent=$(mp.json())".fox_error()
	return 0
}
void* call_variadic_ptr(map* mp,void* fp,char* name){
	void*(*ptr)(void* param1,...)=fp
	if !mp => return ptr(End)
	len=mp.map_len()
	if mp[mp->len-1]==(void*)End => len--
	if len==0 => return ptr(End)
	if len==1 => return ptr(mp[0],End)
	if len==2 => return ptr(mp[0],mp[1],End)
	if len==3 => return ptr(mp[0],mp[1],mp[2],End)
	if len==4 => return ptr(mp[0],mp[1],mp[2],mp[3],End)
	if len==5 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],End)
	if len==6 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],End)
	if len==7 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],End)
	if len==8 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],End)
	if len==9 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],End)
	if len==10 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],End)
	if len==11 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],End)
	if len==12 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],End)
	if len==13 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],End)
	if len==14 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],End)
	if len==15 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],End)
	if len==16 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],End)
	if len==17 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],End)
	if len==18 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],End)
	if len==19 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],End)
	if len==20 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],End)
	if len==21 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],End)
	if len==22 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],End)
	if len==23 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],End)
	if len==24 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],End)
	if len==25 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],End)
	if len==26 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],End)
	if len==27 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],End)
	if len==28 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],End)
	if len==29 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],End)
	if len==30 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],mp[29],End)
	if len==31 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],mp[29],mp[30],End)
	if len==32 => return ptr(mp[0],mp[1],mp[2],mp[3],mp[4],mp[5],mp[6],mp[7],mp[8],mp[9],mp[10],mp[11],mp[12],mp[13],mp[14],mp[15],mp[16],mp[17],mp[18],mp[19],mp[20],mp[21],mp[22],mp[23],mp[24],mp[25],mp[26],mp[27],mp[28],mp[29],mp[30],mp[31],End)
	"Only 32 parameters supported in call to function $name sent=$(mp.json())".fox_error()
	return 0
}
