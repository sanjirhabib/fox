#include <fox.h>

char* fkey_sql(char* sql,char* db){
	cols=sql.sql_select_cols(db)
	pkey=cols.cols_pkeys(db)[0]
	skey=cols.cols_skeys(db)[0]
	ret=sql.sql_map(db)
	ret.select={id: cols[pkey].expr, name: cols[skey].expr}
	return ret.map_sql().sql_add_order(db)
}
char* callback_php(map* param,char* name) => return param.call_php(name)
char* fkey_show(char* sql,char* db,char* id){
	sign="$sql/$id"
	ret=''
	if (ret=sign.cache(:str_show)) => return ret
	return sign.cache(:str_show,sql.fkey_sql(db).sql_add_where({id: ':id'}).sql_row(db,{id: id}).name)
}
int fkey_valid(char* sql,char* db,char* id){
	return sql.fkey_show(db,id) ? 1 : 0
}
char* str_show(char* value,char* type,map* op=NULL,int width=0){
	value=value.to_str()
	if !value => return ""
	if !type => return value
	if op.list => return op.list[value] ? op.list[value].str_title() : value
	if op.sql && op.db => return op.sql.fkey_show(op.db,value)
	type={{
		text text
		para para
		source source
		password password
		html html
		guid guid
		amount number
		mins mins
		debit debit
		credit credit
		bool bool
		email email
		date date
		quarter quarter
		file file
		jpeg image
		duration duration
	}}.map_type(type)
	if width && type.is_word("source text para") && value.str_len()>width*256 => value=value.sub_str(0,width*256)
	if type===:bool => return value.is_int() ? 'Yes' : 'No'
	if type===:text => return value.str_html()
	if type===:file => return value.str_len().int_kb()
	if type===:para => return value.str_html().str_replace("\n","<br>")
	if type===:source => return "<pre>"..value.str_html().."</pre>"
	if type===:html => return value
	if type===:number => return value.int_human(op.unit)
	if type===:debit => return value.int_human(op.unit)
	if type===:credit => return (-value.to_int()).int_human(op.unit)
	if type===:password => return "****"
	if type===:email => return "<a href='mailto:"..value.str_html().."'>"..value.str_html().."</a>"
	if type===:guid => return '<ID>'.str_html()
	if type===:mins => n=value.to_int(); return mstr("%d:%02d",n/60,n%60)
	if type===:duration => return 'Duration/Pending'
	if type===:date => return value.datetime_human()
	if type===:quarter => return 'Pending-Qurter'
	if type===:image => return value ? "<img src=".._globals.base_url.."/"..value.thumb_name().."></img>" : "--"
	return value
}
char* cols_show(map* cols,map* row,char* name,int width=2){
	return row[name].str_show(cols[name].type,cols[name],width)
}
char* datetime_human(char* in){
	if !in => return ''
	char buffer[64]
	time_t time=in.str_time()
	strftime(buffer,buffer.sizeof(), "%a %e-%b-%Y %l:%M %p",localtime(&time))
	return buffer.str_dup()
}
char* thumb_name(char* name){
	parts=name.str_split("/")
	ext=parts.vec_pop()
	parts[]='thumbnail'
	parts[]=ext
	return parts.map_join("/")
}
map* row_show(map* row,map* cols,int width=2){
	ret={}
	row.each v,f
		if cols[f] => ret[f]=cols.cols_show(row,f,width)
		else ret[f]=v
	return ret
}
map* rows_show(map* rows,map* cols,int width=2){
	ret=[]
	rows.each row,k,i
		r={}
		row.each v,f,i2
			if cols[f] => r[f]=cols.cols_show(row,f,width)
			else r[f]=v
		ret[]=r
	return ret
}

char* month_name(int month) => return {:Jan,:Feb,:Mar,:Apr,:May,:Jun,:Jul,:Aug,:Sep,:Oct,:Nov,:Dec}[abs(month-1)%12]
char* http_moved(char* url) => return NULL.http_out("301 Moved Permanently","text/html",["Location: $url"])
char* http_redirect(char* url,char* msg=''){
	if msg => _globals.sess.msg=msg
	return NULL.http_out("302 Moved Temporarily","text/html",["Location: $url"])
}
void* http_error(char* msg,char* status) => msg.http_out(status); xexit(0); return NULL
char* file_mime(char* path){
	_globals.mime.each v,k,i
		if(path.str_end(k)) return v
	return NULL
}
char* str_html(char* in){
	if !in.str_len() => return ""
	chars="<>\"'&"
	into=["&lt;","&gt;","&quot;","&#039;","&amp;"]
	ret=''
	for ;*in;in++
		char* match=chars.strchr(*in)
		if !match => ret=ret.cat_char(*in)
		else ret.=into[match-chars]
	return ret
}
void header(char* str) => str.print(); "\r\n".print()
char* http_out(char* str=NULL,char* status="200 OK",char* mime="text/html; charset=utf-8",map* headers=NULL){
	static int callonce=0
	if callonce => return str
	callonce=1
	sess=_globals.sess.json()
	if sess==="{}" => sess=NULL
	if _globals.sess_str!==sess
		_globals.sess=NULL
		_globals.sess_str=NULL
		sid=_globals.sess_id
		if !sid && sess
			sid=sess_newid()
			:sessid.cookie_set(sid)
		if !sess && sid
			if "/tmp/sess.$sid".is_file() => "/tmp/sess.$sid".unlink()
		else if sess && sid
			sess.write_file("/tmp/sess.$sid",0,0)
	out=_globals.out..str
	"Status: $status".header()
	"Content-Type: $mime".header()
	"Content-Length: $(out.str_len())".header()
	headers.each v,,i => v.header()
	_globals.cookie.each v2
		"Set-Cookie: $v2".header()
	"".header()
	out.print()
	xexit(0)
	return str
}
char* static_file(char* path){
	if path.has_word("? ../ /.. \\") => return NULL
	if !path.str_start("/res/") => return NULL
	ret="/web/".cat(path.str_trim("/")).file_read(,0)
	if ret => return ret.http_out("200 OK",path.file_mime())
	return NULL
}

char* str_url(char* in){
	if !in||!*in => return in
	bad=0
	head=in
	for ;*in;in++
		if !is_alphanum(*in,"\"'-.[]*$%{}()@!~") => bad++
	if !bad=> return head
	ret=new_str(head.str_len()+bad*2)		
	off=0
	in=head
	for ;*in;in++
		if !is_alphanum(*in,"\"'-.[]*$%{}()@!~")
			sprintf(ret+off,"%%%02X",(unsigned char)*in)
			off+=3
		else
			ret[off]=*in
			off++
	return ret
}
char* url_str(char* in){
	if !in => return NULL
	int len=0
	int fix=0
	str=in
	for(;*in;in++)
		if *in=='+' => fix=1
		else if *in=='%' => fix=1; len-=2
	if !fix => return str
	ret=new_str(str.str_len()+len)
	int i=0
	for(in=str;*in;in++,i++)
		if *in=='+' => ret[i]=' '
		else if *in=='%' => ret[i]=(++in).hex_char(); in++
		else ret[i]=*in
	return ret
}
char* map_amps(void* val,char* name=''){
	if !val => return ''
	if !val.is_map()
		val=val.to_str()
		return name ? name.str_url().."="..val.str_url() : ''
	ret=''
	if name => name.="."
	val.each v,n
		ret=ret.str_join("&",v.map_amps(name..n))
	return ret
}
map* amps_map(char* in){
	ret={}
	in.str_split("&",0).each v,,i
		pr=v.str_split("=",2)
		key=pr[0].url_str()
		if !key.strchr('.')
			ret[key]=pr[1].url_str()
			continue
		keys=key.str_split(".")
		lastkey=keys[keys.map_len()-1]
		keys.vec_del(-1)
		val=ret
		keys.each k
			nval=val[k]
			if !nval.is_map() => nval={}; val[k]=nval
			val=nval
		val[lastkey]=pr[1].url_str()
	return ret
}
map* parse_url(char* path){
	ret={url: path}
	two=path.str_split("?",2)
	ret.path=two[0]
	ret.get=two[1].amps_map()
	return ret
}
char* url_host(char* url) => return url.regexp("://([^:/]+)")[1]
map* sess_init(){
	sid=env_vars().HTTP_COOKIE.header_map().sessid
	if !sid => return NULL
	sess="/tmp/sess.$sid".file_read(,0)
	_globals.sess_id=sid
	_globals.sess_str=sess
	_globals.sess=sess.xjson_map()
	return _globals.sess
}
void	sess_add(char* name, char* value) => _globals.sess[name]=value
char*	sess_id()		=> return _globals.sess_id
char*	sess_file()		=> return sess_id() ? "/tmp/sess.$(sess_id())" : NULL
char*	sess_newid()	=> return rand_str(24)
void cookie_set(char* name,char* value,char* path="/",char* expire=NULL){
	xexpire=''
	if expire => xexpire="; expires=$expire"
	ss="$name=$value; path=$path$xexpire"
	_globals.cookie[]=ss
}
void sess_delete(){
	if !sess_file() => return
	sess_file().remove()
	:sessid.cookie_set(:NULL,,"Thu, 01 Jan 1970 00:00:00 GMT")
}
map* link_relative(map* links,char* url){
	if(!links||!url) return links
	prepad="../".str_times(url.str_char_count('/')+1)
	links.each v,,i
		if v.is_map()
			v.link_relative(url)
			continue
		if(v.fox_at(0)=='/') continue
		links[i]=prepad..v
	return links
}
map* header_map(char* val){
	if !val => return NULL
	ret={}
	val.str_split(";").each v,,i
		if !v.strchr('=') => ret[]=v; continue
		pair=v.str_split("=",2)
		ret[pair[0].str_trim()]=pair[1].str_trim().str_unquote()
	return ret
}
map* http_req(){
	ret={}
	env=env_vars()
	sess_init()
	_globals.css={}
	_globals.js={}
	if !env.REQUEST_METHOD
		path=_globals.args[1]
		char* home=cwd().sub_str((cwd()+1).char_at("/")+1).."/"
		//char* home="https://sanjir.com"..cwd().sub_str((cwd()+1).char_at("/")+1).."/"
		ret=(home..path).parse_url()
		ret.method=:get
		ret.remote=:localhost
		ret.server=:localhost
		ret.protocol=:http
		ret.port="80"
		ret.path={
			full: ret.path
			home: home
			next: ret.path.sub_str(home.str_len()) or "/"
		}
		_globals.req=ret
		return ret
	ret=env.REQUEST_URI.parse_url()
	ret.remote=env.REMOTE_ADDR
	ret.server=env.HTTP_HOST
	ret.protocol=env.REQUEST_SCHEME
	ret.port=env.SERVER_PORT
	char* home=env.SCRIPT_NAME.rtrim_upto('/',1)
	ret.path={
		full: ret.path
		home: home
		next: ret.path.sub_str(home.str_len()) or "/"
	}
	if env.REQUEST_METHOD===:GET
		ret.method=:get
		_globals.req=ret
		return ret
	if env.REQUEST_METHOD!==:POST
		"Method $(env.REQUEST_METHOD) not supported".http_error("405 Method not supported")
	ret.method=:post
	size=env.CONTENT_LENGTH.str_int()
	if !size => "Content-Lenght was not provided".http_error("411 Length Required")
	if size>20000000 => "Request should be with less than 20MB data".http_error("413 Request Entity Too Large")
	char line[1024]
	header=new_blob()
	done=0
	done1=0
	int toread=min(size-done,1024)
	while done<size && (done1=STDIN_FILENO.read(line,toread))
		if done1<=0 => "POST data read error at $done/$size bytes".http_error("500 Internal Server Error")
		header=header.cat(line,done1)
		done+=done1
		toread=min(size-done,1024)
	ret.post=header
	_globals.req=ret
	return ret
}
char* full_url(char* url=NULL) => return (_globals.req.protocol or :http).."://"..(_globals.req.server or :localhost)..show_port().."/"..url.str_ltrim("/")
//char* full_path(char* url=NULL) => return "/"..url.str_ltrim("/")
char* url_abs(char* abs, char* rel){
	if !rel => return abs
	if rel.str_start("./") => return abs..rel.sub_str(2)
	if rel[0]!='.' => return abs..rel
	srel=rel
	level=0
	while srel.str_start("../") => srel+=3; level++
	base=abs.str_split("/")
	if abs.strstr("://") => level=max(base.map_len()-level-1,3)
	else level=max(base.map_len()-level-1,0)
	ret=base.vec_sub(0,level).map_join("/")
	return ret.."/"..srel
}
char* base_url(char* path=NULL) => return _globals.tabs.map_key(0).url_abs(path)
char* home_url(char* path=NULL) => return _globals.req.path.home.url_abs(path)
char* show_port(){
	if !_globals.req.port => return ''
	if _globals.req.protocol===:http && _globals.req.port==="80" => return ''
	if _globals.req.protocol===:https && _globals.req.port==="443" => return ''
	return ":".._globals.req.port
}
char* h(char* in){
	return in.str_replace({
	"&": "&amp;",
	"<": "&gt;",
	">": "&lt;",
	"\"": "&quot;",
	"'": "&apos;"
	})
}
extern int _queries;
char* page_html(map* data){
	head=---
	<!DOCTYPE html>
	<html><head><meta charset='utf-8'>
	<title>$(data.title)</title>
	<script type="application/ld+json">
	{
		"@context": "http://schema.org",
		"@type": "WebSite",
		"name": "Habib's Site",
		"alternateName": "Sanjir Habib",
		"url": "$(_globals.req.path.full.full_url())"
	}
	</script>
	<link rel="apple-touch-icon" href="/apple-touch-icon.png">
	<meta name="application-name" content="habib"/>
	<meta name="msapplication-square70x70logo" content="/small.jpg"/>
	<meta name="msapplication-square150x150logo" content="/medium.jpg"/>
	<meta name="msapplication-wide310x150logo" content="/wide.jpg"/>
	<meta name="msapplication-square310x310logo" content="/large.jpg"/>
	<meta name="msapplication-TileColor" content="#fff"/>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	$(data.header)
	<link rel='icon' href='$(data.logo)'></link>
	</head><body>

	---;
	if _globals.req.get._print
		return ---
		$head
		$(data.body)
		</body></html>
		---
	return ---
	$head
	<div class='row-fluid alert-success'><span class='span8' style='padding-left:2em;'>$(data.msg)</span>$(data.login)</div>
	<div class=row-fluid>
	<div class='span3' style='text-align:center;'><a href='$(data.home)'><img style='width:auto;height:100px;padding:.3em;' src='$(data.logo)'></img></a></div>
	<div class='span7'>
	<h2 style='text-align:center;'>$(data.title)</h2>
	<div style='border-top:1px solid gray;border-bottom:1px solid gray;min-height:0.2em;text-align:center;'>$(data.desc)</div>
	</div>
	</div>
	$(data.tabs)$(data.ldmenu)
	<div class=container-fluid>
	<div class=row-fluid>$(data.body)</div>
	<hr noshade=noshade style="width:70%;margin:auto;height:1px;margin-bottom:.5em;margin-top:8em;color:gray;">
	<div class=footer style='color:#333;font-size:small;text-align:center;'>
	&copy; Habib &lt;habib@habibur.com&gt;. $(data.hits) $(data.footer)
	</div>
	</div>
	</body></html>

	---
}
map* page_data(map* data){
	data.title||="Habib's Site"
	data.tab||=data.title
	data.logo||="logo.jpg".home_url()
	data.home||=home_url()
	data.css&&="<style>\n$(data.css)</style>\n"
	data.msg||=_globals.sess.msg
	_globals.sess.map_del_key(:msg).map_compact()
	head=''
	['/res/bootstrap.css','/res/bootstrap-responsive.css','/res/jquery.js','/res/bootstrap.js']
	.each v
		if v.sub_str(-4)==='.css' => head.="<link rel='stylesheet' href='$v'></link>\n"
		else head.="<script src='$v'></script>\n"
	_globals.jsfile.each v
		head.="<script src='$v'></script>\n"
	data.header=head..data.css
		..(_globals.css.map_len() and "<style>\n".._globals.css.map_join("\n").."</style>\n")
	data.desc||=data.meta.description
	data.meta.description||=data.desc
	data.meta.description||=data.title
	data.meta["og:description"]=data.meta.description
	data.meta["og:title"]=data.title
	data.meta["og:image"]||=data.logo.full_url()
	data.meta.each val, key
		data.header.="<meta property=\"$key\" content=\"$val\">\n"
	if _globals.req.get._print => return data
	data.footer=---
	Run Time: $(run_time())ms=$(gc_time())GC+$(run_time()-total_time()-gc_time())Code+$(total_time())DB
	Heap: $(_gcdata.max_mem.int_kb()). Stack: $(_gcdata.max_roots.int_str()), Total: $(max_mem().int_kb()).
	GC: $(gc_runs())runs. Queries: $(_queries.int_str()).
	---
	data.footer.=(_globals.js.map_len() and "<script>\n".._globals.js.map_join("\n").."</script>")
	tabs=''
	lddata={"@context": "http://schema.org", "@type": "BreadcrumbList"}
	i=1
	_globals.tabs.each name, url, idx
		active=''
		if idx==_globals.tabs.map_len()-1
			active=" class='active'"			
		tabs.="<li$active><a href='$url'>$name</a></li>\n"
			
		lddata.itemListElement[]={
			"@type": "ListItem",
			"position": i++, "item": { "@id": url, "name": name }
		}
	if _globals.tabs.map_len()>1
		data.tabs="<div><ul class='nav nav-tabs'>$tabs</ul></div>"
	data.ldmenu="<script type='application/ld+json'>$lddata</script>"
	body=''
	_globals.css[]=---
	a.menu {overflow:hidden;text-overflow:ellipsis;white-space:nowrap;}
	ul.menu2 {margin-top:5em;}
	---;
	data.menu.each name, url
		body.="<li><a class='menu' href='$url'>$name</a></li>\n"
	if data.menus
		data.menus.each menu, title
			if !menu.map_len() => continue
			body.="</ul><h5 style='text-align:center;'>$title</h5><ul class='nav nav-tabs nav-stacked menu2'>"
			menu.each name, url
				body.="<li><a class='menu' href='$url'>$name</a></li>\n"
	if data.width.is_int()==4
		body="<div class='span11 offset1'><ul class='nav nav-pills'>$body</ul></div>"
	else
		body="<div class=span2><ul class='nav nav-tabs nav-stacked'>$body</ul></div>"

	switch data.width.is_int()
		case 1:
			body.="<div class='span4'>$(data.body)</div><div class=span6>$(data.help)</div>"
		break
		case 3:
			body.="<div class='span10'>$(data.help)$(data.body)</div>"
		break
		case 4:
			body.="</div><div class=row-fluid>$(data.help)$(data.body)</div>"
		break
		default: //=2
			body.="<div class='span7'>$(data.body)</div><div class=span3>$(data.help)</div>"
	data.body=body
	login=''
	if _globals.sess.user
		login="<span class='pull-right'>$(_globals.sess.user) as $(_globals.sess.role) | <a href='$(base_url())logout/'>Logout</a> &nbsp; </span>"
	else
		login="<span class='pull-right' style='margin-right:3em;'><a href='$(base_url())login/'>Login</a> | <a href='$(base_url())register/'>Register</a></span>"
	data.login=login
	return data
}
void* not_found(char* path=NULL) => "The requested content $(path or _globals.req.path.full) was not found on the server.".http_out("404 Not Found"); return NULL
int show_page(map* data) => data.page_data().page_html().http_out(); return 0
int is_post() => return _globals.req.method===:post
map* post_data_multipart(){
	if _globals.post => return _globals.post
	map* mime=env_vars().CONTENT_TYPE.header_map()
	if mime[0]!=="multipart/form-data"
		return _globals.req.post.amps_map()
	ret={}
	char* seperator=mime.boundary
	_globals.req.post.str_split(seperator).each v,,i
		map* mp3=v.str_split("\r\n\r\n",2)
		if mp3.map_len()!=2 => continue
		mp3[0].str_split("\r\n").each v2,k2,i2
			header=v2.header_map()
			if header.name
				ret[header.name].filename=header.filename
				ret[header.name].data=mp3[1].sub_str(0,-4)
				break
	_globals.post=ret
	_globals.req.post=NULL
	return ret
}
char* name_tab(char* name){
	_globals.tabs[_globals.paths.matched.home_url()]=name
	return name
}
map* get(char* path, map* names=NULL){
	ret=_globals.req.path.next.regexp("^"..path)
	if !ret => return NULL
	ret2=_globals.paths
	if !ret2 => _globals.paths={}; ret2=_globals.paths
	if names
		for i=1; i<ret.map_len() && i<=names.map_len(); i++
			ret2[names.map_id(i-1)]=ret[i]
	ret2.matched=ret[0]
	ret2.end=_globals.req.path.next.regexp("^"..path.."$") ? "yes" : NULL
	return ret2
}
void show_body(char* body,map* page){
	page.body=body
	page.show_page()
}
int days_in_feb(int year){
	if !(year%400) => return 29
	if !(year%100) => return 28
	if !(year%4) => return 29
	return 28
}
int days_in_month(int month,int year){
	if month==4||month==6||month==9||month==11 => return 30
	if month==2 => return days_in_feb(year, month)
	return 31
}
char* add_tab(char* path=NULL,char* name=NULL){
	if path && path[path.str_len()-1]!='/' => path.="/"
	path = path ? path.home_url() : _globals.paths.matched.home_url()
	if !name
		if !path || path==="/" => name=:Home
		else
			i=path.str_len()-1
			while(i && path[--i]!='/'){}
			name=path.sub_str(i+1,-1).str_title()
	_globals.tabs[path]=name
	return name
}
char* tz_dst(char* tz=NULL, char* date=NULL){
	time_t ret=date.str_time()
	if tz => setenv(:TZ, tz, 1);
	struct tm* tm=localtime(&ret)
	return tm->tm_isdst==1 ? :DST : ''
}
double tz_offset(char* tz=NULL, char* date=NULL){
//in hours
	time_t ret=date.str_time()
	struct tm tm={0}
	gmtime_r(&ret,&tm)
	if tz => setenv(:TZ, tz, 1)
	struct tm tml={0}
	localtime_r(&ret,&tml)
	tm.tm_isdst = tml.tm_isdst
	time_t gm=mktime(&tm)
	return (ret-gm)/3600.0
}
char* tz_utc(char* tz, char* date=NULL) => return tz.tz_offset(date).offset_utc()
char* offset_utc(double off){
	if !off => return :UTC
	sign=off<0 ? '-' : '+'
	off=fabs(off)
	if off-floor(off)<1/100. => return mstr("UTC%c%d",sign,(int)off)
	return mstr("UTC%c%d:%02d",sign,(int)off,(int)((off-(int)off)*60+0.5))
}
char* date_ymd(char* in,int* year, int* month,int* day){
	*year=*month=*day=0
	if !in => return NULL
	sscanf(in,"%04d-%02d-%02d",year,month,day)
	return in
}
char* date_human(char* in){
	year=0
	month=0
	day=0
	in.date_ymd(year,month,day)
	return day.."-"..month.month_en3().."-"..year
}
char* tz_human(double tz){
	if !tz => return :UTC
	mins=(int)(frac(tz)*60)
	if !mins => return mstr("UTC%c%d", tz<0 ? '-' : '+', abs((int)(tz)), mins)
	return mstr("UTC%c%d:%d", tz<0 ? '-' : '+', (int)(tz), mins)
}
map* tz_data(char* name,char* date=NULL){
	return {{
		name =name
		offset =name.tz_offset(date)
		dst =name.tz_dst(date)
		utc =name.tz_utc(date)
	}}
}
char* fts5_create(char* db=NULL){
	ret=[
	"drop table if exists search",
	"create virtual table search using fts5(table,key,title,body,thumb)"
	]
	if db => ret.sqls_exec(db)
	return ret.map_join(";\n")
}
map* merge_soft(map* strong, map* soft){
	if !strong => strong={}
	if !soft => return strong
	soft.each val, key
		if !key.is_int()
			if strong.map_has_key(key) => continue
		else key=''
		strong[key]=val
	return strong
}
char* param(map* change=NULL){
	return change.merge_soft(_globals.req.get).map_amps()
}
void save_caller(){
	refer=url_back()
	req=_globals.req
	if req.method!==:get || !refer || req.get._refer || refer.str_end(req.path) => return
	req.get._refer=refer
	"./?$(req.get.map_amps())".http_redirect()
}
char* url_back(){
	return _globals.req.get._refer or env_vars().HTTP_REFERER.parse_url().path or home_url()
}
char* form_html(map* mp){
	mp.vals.each val,key
		if mp.cols[key] => mp.cols[key].value=val
	ret=---
	<fieldset><legend>$(mp.title)</legend>
	<p class='text-$(mp.error ? :error : :info)'>$(mp.msg)</p>
	<form method=$(mp.method or :post)>
	---
	mp.cols.each val, name
		ret.=---
		<div class="control-group">
		<label>$(val.label or val.name.str_title())</label>$(val.ctrl_html())
		<span class='help-block'>$(mp.error[name])</span>
		</div>
		---
	ret.="<div class='form-actions'><div class='btn-group'>"
	mp.buttons.each val, name, idx
		ret.=---
		<input class='btn$(!idx ? " btn-primary" : "")' type='submit' name='$(val.name)' value='$(val.name.str_title())'>
		---
	ret.="</div></div>"
	ret.="</form>"
	return ret
}
map* param_map(char* in){
	ret={}
	in.str_split("&").each val
		two=val.str_split("=",2)
		ret[two[0]]=two[1]
	return ret
}
map* post_data() => return _globals.req.post.amps_map()
map* form_posted(map* form){
	save_caller()
	if _globals.req.method!==:post => return NULL
	param=post_data()
	form.buttons.each ,key
		if param[key]
			form.cols.each val,key
				val.value=param[key]
			return param
	return NULL
}
char* ctrl_html(map* ctrl){
	id=ctrl.id or ctrl.name.name_id()
	if ctrl.list
		ret="<option value=''>--</option>"
		ctrl.list.each val, key
			ret.="<option value='$(key.h())'$(ctrl.value===key ? ' selected' :'')>$(val ? val.h() : key.str_title().h())</option>"
		return "<select name='$(ctrl.name)' id='$id' class='input-medium'>$ret</select>"
	type={{
		text text
		code code
		para para
		source source
		password password
		hidden hidden
	}}.map_type(ctrl.type)
	if type===:code
		return ---
		<input type=text name=$(ctrl.name) value="$(ctrl.value)" id=$id size="input-$(ctrl.size or :medium)"></input>
		---
	if type===:text
		return ---
		<input type=text name=$(ctrl.name) value="$(ctrl.value)" id=$id size="input-$(ctrl.size or :large)"></input>
		---
	if type===:para
		return ---
		<textarea class="para" style="width:20em; height:10em;" id=$id name='$(ctrl.name)'>$(ctrl.value)</textarea>
		---
	if type===:hidden
		return ---
		<input type=hidden name=$(ctrl.name) value="$(ctrl.value)" id=$id></input>
		---
		
	if type===:source
		static int codeincluded=0
		if !codeincluded
			_globals.jsfile[]='/res/jquery.textarea.js'
			_globals.css[]=".source {font-family:courier;overflow:auto;width:100%;height:30em;}"
			_globals.js[]="$$(\"#$id\").tabby()"
			codeincluded=1
		return ---
		<textarea id=$id class='source' wrap='soft' name='$(ctrl.name)'>$(ctrl.value)</textarea>
		---
	if type===:password
		return ---
		<input type=password name=$(ctrl.name) value="$(ctrl.value)" id=$id></input>
		---
	return "control type $(ctrl.type) unspported. please provide support in ctrl_html()"
}
char* name_id(char* name){
	return name
}
map* form_gets(map* form){
	_globals.req.get.vals.each val,key
		if form.cols[key] => form.cols[key].value=val
	return form
}
int show_form(map* data){
	data.body=data.form_html()
	return data.show_page()
}
int is_user(char* who) => return !who.str_len() || _globals.sess.user===who || _globals.sess.role===who
void authorized(char* who) => if !who.is_user() => _globals.req.path.not_found()
char* col_align(map* col){
	if col.sql || col.list => return ''
	if {{
		text text
		int
	}}.map_type(col.type)===:text => return ''
	return " style='text-align:right;'"
}
char* rows_data_html(map* in){
	return ---
	<table class='table table-condensed table-bordered table-striped'>
	<thead>
	<tr>$(in.head)</tr>
	</thead>
	<tbody>
	<tr>$(in.body.map_join("</tr>\n<tr>"))</tr>
	</tbody>
	</table>

	---;
}
map* rows_data(map* rows, map* cols){
	head=''
	cols.each val
		head.="<th$(val.col_align())>$(val.label or val.name.str_title())</th>"
	body={}
	rows.each row
		s=''
		row.each val, key
			s.="<td$(cols[key].col_align())>$(val)</td>"
		body[row.row_id(cols)]=s
	return {head: head, body: body}
}
char* row_id(map* row, map* cols) => return row.row_ids(cols).map_join("\t").str_url()
map* row_ids(map* row, map* cols){
	ret=cols.cols_pkeys()
	ret.each name
		ret[name]=row[name]
	return ret
}
void crud(char* sql,char* db){
	path=_globals.paths	
	curr=path.matched
	table=sql.sql_table()
	if path.end
		rows=sql.sql_rows(db)
		cols=sql.sql_cols(db)		
		data=rows.rows_data(cols)
		data.head=---
		<th style='text-align:center;'>
		<div class="btn-group">
		<button class="btn btn-mini">Action</button>
		<button class="btn btn-mini dropdown-toggle" data-toggle="dropdown">
		<span class="caret"></span>
		</button>
		<ul class="dropdown-menu">
			<li><a href="add/">Add New</a></li>
		</ul>
		</div>		
		</th>

		---..data.head
		data.body.each row,key
			data.body[key]=---
			<td style='text-align:center;'>
			<div class="btn-group">
			<button class="btn btn-mini dropdown-toggle" data-toggle="dropdown">
			<span class="caret"></span>
			</button>
			<ul class="dropdown-menu">
				<li><a href="id.$key/edit/">Edit</a></li>
				<li><a href="id.$key/delete/">Delete</a></li>
			</ul>
			</div>		
			</td>

			---..row
		data.rows_data_html().show_body({{
			title =sql.sql_table().str_title().." List"
			width =4
		}})
		return
	if "$(curr)add/".get().end
		:Add.name_tab()
		cols=sql.sql_cols(db).del_keys([:lft,:rgt])
		form={{
			title ="Add New $(table.str_title())"
			cols =cols
			buttons
				save -
		}}
		data=form.form_posted()
		if data
			data.row_insert(table, db)
			url_back().http_redirect("Record Added")
		form.form_gets().show_form()
	"$(curr)id.([^/]+)/".get([:id])
	if "$(curr)id.[^/]+/edit/".get().end
		:Edit.name_tab()
		table=sql.sql_table()
		row=path.id.id_row(table, db)
		cols=sql.sql_cols(db).del_keys([:lft,:rgt])
		form={{
			title ="Edit $(table.str_title())"
			cols =cols
			vals =row
			buttons
				save -
		}}
		data=form.form_posted()
		if data
			row.row_ids(table.tbl_cols(db)).id_update(table, db, data)
			url_back().http_redirect("Record Updated")
		form.show_form()
	if "$(curr)id.[^/]+/delete/".get().end
		:Delete.name_tab()
		form={{
			title Delete This Record?
			buttons
				delete -
				cancel -
		}}
		data=form.form_posted()
		if data.cancel
			url_back().http_redirect(:Cancelled)
		else if data.delete
			path.id.id_delete(table,db)
			url_back().http_redirect("Record Deleted")
		form.show_form()
	not_found()
}
map* del_keys(map* mp,map* keys){
	keys.each key => mp.map_del(mp.map_has_key(key)-1).map_compact()
	return mp
}
char* str_bare(char* in,char* accept=NULL){
	if !in => return in
	ret=in
	while *in
		if *in>0 && !(*in).is_alphanum(accept) => *in=' '
		in+=in.utf_len()
	return ret
}
char* word_end(char* in,int len){
	if in.str_len()<=len => return in
	ptr=in+len
	while *ptr && !" \t\n\r".str_chr(*ptr) => ptr++
	if !*ptr => return in
	return in.sub_str(0,ptr-in)
}
void go_back(char* msg) => url_back().http_redirect(msg)
int confirm(char* msg="Confirm?"){
	form={{
		title =msg
		buttons
			yes -
			cancel -
	}}
	data=form.form_posted()
	if data.yes
		return 1
	if data => return 0
	return form.show_form()
}
void retree(char* db){
	rows=:section.sql_rows(db)
	"delete from section".sql_exec(db)
	rows.each row
		row.map_del_key(:lft)
		row.map_del_key(:rgt)
		row.row_insert(:section,db)
}
char* html_text(char* in){
	len=0
	head=in
	while *in
		if *in=='<'
			if in.str_starti("<script")
				while *in && !in.str_starti("</script") => in++
			if in.str_starti("<style")
				while *in && !in.str_starti("</style") => in++
			while *in && *in!='>' => in++
			if *in=='>' => in++
			continue
		in++
		len++	
	if len==in.str_len() => return in
	ret=len.new_str()
	len=0
	in=head
	while *in
		if *in=='<'
			if in.str_starti("<script")
				while *in && !in.str_starti("</script") => in++
			if in.str_starti("<style")
				while *in && !in.str_starti("</style") => in++
			while *in && *in!='>' => in++
			if *in=='>' => in++
			continue
		ret[len++]="\n\r".strchr(*in) ? ' ' : *in
		in++
	return ret
}
char* url_filename(char* url){
	question=url.rchar_at("?")
	if question>=0 => url=url.sub_str(0,question)
	slash=url.rchar_at("/")
	if slash<0 => return url
	return url.sub_str(slash+1)
}
