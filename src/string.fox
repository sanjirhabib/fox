#include <fox.h>

char* mstr(char* format, ...){
	ret=''
	va_list args
	args.va_start(format)
	ret=format.va_str(args)
	args.va_end()
	return ret
}
char* cat_char(char* str, char c){
	if !str => return c.char_str()
	len=str.str_len() //lima
	str=str.fox_realloc(len+2,String)	
	str[len]=c;
	assert(!str[len+1])
	return str
}
char* va_str(char* format,va_list args){
	if !format => return NULL
	va_list copy
	copy.va_copy(args)
	int len=NULL.vsnprintf(0,format,args)
	ret=new_str(len)
	ret.vsnprintf(len+1,format,copy)
	copy.va_end()
	return ret
}
void* dx(void* data="**",char* name=NULL,int panic=0){
	if name
		"$name=".px(0)
	data.to_str(:NULL,1).px()
	if panic==1 => xexit(0)
	else if panic==2 => fox_stack_dump()
	return data
}
int neq(char* str,char* str1) => return str!==str1
int eq(char* str,char* str1) => return !str||!str1||!str.is_str() ? 0 : str.strcmp(str1)==0
char* cwd(){
	char* ret=getcwd(NULL,0)
	ret2=ret.str_dup()
	ret.free()
	return ret2
}
char* str_unquote(char* str){
	if !str||!*str => return NULL
	if str==="\"\"" || str==="''" => return ""
	if *str=='\'' || *str=='"' => str=str.sub_str(1,-1)
	if !str.str_chr('\\') => return str
	temp=str.str_dup()
	ret=temp
	while *str
		other=0
		if *str=='\\'
			str++
			if !*str => break
			switch *str
				case 'n': *temp='\n'; break
				case 'r': *temp='\r'; break
				case 't': *temp='\t'; break
				case '0': *temp='\0'; break
				default: other=1; break
			other=!other
		if !other => *temp=*str
		temp++
		str++
	*temp=0
	return ret
}
char* str_escape(char* head){
	if !head => return ""
	len=head.str_len()
	assert(len<4000)
	extra=0
	char c
	str=head
	quotable="\\\""
	quoteto="\\\""
	while((c=*str++)) if quotable.strchr(c) => extra++
	assert(extra<=len)
	ret=new_str(head.str_len()+extra)
	str=head
	i=0
	fox_at=''
	while((c=*str++))
		if !(fox_at=quotable.strchr(c)) => ret[i++]=c; continue
		ret[i++]='\\'
		ret[i++]=quoteto[fox_at-quotable]
		assert(i<len+extra+2)
	
	assert(!ret[i])
	return ret
}
char* str_end(char* str,char* end){
	if str.str_len()<end.str_len() => return NULL
	return strcmp(str+str.str_len()-end.str_len(),end)==0 ? str : NULL
}
int str_starti(char* str,char* start){
	if !str || !start || !*str || !*start => return 0
	for i=0; i<start.strlen(); i++
	while *str && *start
		if *str!=*start
			c=*str 
			if c>='A' && c<='Z' => c+='a'-'A'
			if c!=*start => return 0
		start++
		str++
	if *start => return 0
	return 1
}
int str_start(char* str,char* start) => return str && start && str.is_str() && str.strncmp(start,start.strlen())==0
char* str_chr(char* str,char c) => return !str||!c||!str.is_str() ? NULL : str.strchr(c)
int str_chrs(char* str,char* chars){
	for i=0; i<chars.strlen(); i++
		if str.str_chr(chars[i]) => return 1
	return 0
}
char* str_ltrim(char* str,char* chars=" \t\n\r"){
	if !str || !*str => return NULL
	return str+str.lchars(chars)
}
char* str_rtrim(char* str,char* chars=" \t\n\r"){
	if !str || !*str => return NULL
	r=str.rchars(chars)
	if !r => return str
	return str.sub_str(0,str.str_len()-r)
}
char* str_trim(char* str,char* chars=" \t\n\r"){
	l=str.lchars(chars)
	r=str.rchars(chars)
	if !l && !r => return str
	return str.sub_str(l,str.str_len()-l-r)
}
int line_isempty(char* line){
	while(*line && *line!='\n' && *line!='\r'){ if(*line!=' ' && *line!='\t') return 0; line++; }
	return 1
}
int line_len(char* line){
	ret=0
	while(*line && *line!='\n' && *line!='\r'){ ret++; line++; }
	if *line=='\r' => ret++; line++
	if *line=='\n' => ret++
	return ret
}
int lchars(char* str,char* chars){
	if !str||!chars => return 0
	ret=0
	while str[ret]
		if chars.strchr(str[ret]) => ret++
		else break
	
	return ret
}
int rchars(char* str,char* chars,int off=0){
	if !str||!chars => return 0
	ret=0
	len=str.str_len()+off
	while ret<len
		if chars.strchr(str[len-ret-1]) => ret++
		else break
	
	return ret
}
int has_str(char* str,char* substr){
	if !str||!substr => return 0
	ret=0
	while *str
		if str.str_start(substr) => ret++
		str++
	return ret
}
char* str_replace(char* str,void* find,void* replace=NULL){
	if !str || !find || !str.str_len() => return str
	assert(str.is_str())
	if find.is_str()
		if !str.str_has(find) => return str
		assert(replace.is_str())
		find={(find) : replace}
	assert(find.is_map())
	dels=0
	adds=0
	find.each v,k,i2
		assert(k.is_str())
		if v.is_i() => find[i2]=(v=v.is_int().int_str())
		assert(!v || v.is_str())
		i=str.has_str(k)
		if !i => continue
		dels+=i*k.str_len()
		adds+=i*v.str_len()
	if !dels => return str
	ret=new_str(str.str_len()+adds-dels)
	temp=str
	temp2=ret
	for ;*temp;temp++,temp2++
		found=0
		find.each v3, k3, i3
			if temp.str_start(k3)
				if v3
					temp2.strcat(v3)
					temp2+=v3.strlen()-1
				else
					temp2--
				temp+=k3.strlen()-1
				found=1
				break
		if !found => *temp2=*temp
	return ret
}
char* str_str(char* in, char* sub){
	len=in.str_len()
	sublen=sub.str_len()
	for i=0; i<=len-sublen; i++
		ok=1
		for j=0; j<sublen; j++
			if sub[j]!=in[i+j]
				ok=0
				break
		if ok => return in+i
	return NULL
}
char* str_upper(char* s){
	ret=s
	for(;*s;++s) *s=toupper(*s)
	return ret
}
char* str_lower(char* s){
	ret=s
	for(;*s;++s) *s=tolower(*s)
	return ret
}
char fox_at(char* str,int idx){
	if !str || !str.is_str() => return '\0'
	if(idx<0) idx+=str.str_len()
	return idx<str_len(str) ? str[idx] : '\0'
}
char* indent_str(int i){
	ret=new_str(i+1)
	ret.memset('\t',i+1)
	ret[0]='\n'
	return ret
}
int str_chars(char* str,char* chars){
	if !str || !chars || !str.is_str() => return 0
	int len1=str.strlen()
	int len2=chars.strlen()
	for i=0;i<len1;i++
		for j=0;j<len2;j++
			if str[i]==chars[j] => return 1
	return 0
}
char* end_word(char* str,char* words){
	if !str||!words => return NULL
	word=words.str_dup()
	int total=word.terminate_words()
	for int i=0;i<total;i++
		ret=str.str_end(word)
		if ret => return ret
		word+=word.str_len()+1
	
	return NULL
}
char* has_word(char* str,char* words){
	if !str||!words => return NULL
	word=words.str_dup()
	int total=word.terminate_words()
	for int i=0;i<total;i++
		char* ret=str.strstr(word)
		if ret => return ret
		word+=word.str_len()+1
	
	return NULL
}
int is_word(char* word,char* list){
	assert(list)
	assert(list.is_str())
	if !word.is_str() => return 0
	ret=list
	while (ret=ret.str_has(word))
		if ret && (ret==list||ret[-1]==' ') && (ret[word.strlen()]==' '||!ret[word.strlen()]) => return ret-list+1
		ret+=word.strlen()
	return 0
}
int terminate_words(char* in){//Takes a string and adds NULL between eash words. Returns total number of words terminated with NULL
	if !in => return 0
	s=in
	int ret=1
	for(;*s;s++) if *s==' ' => ret++; *s='\0'
	return ret
}
int is_number(char c) => return (c>='0' && c<='9') || c=='.' || c=='-' || c=='+'
int is_alphanum(char c,char* others=NULL){
	if (c>='a' && c<='z') || (c>='A' && c<='Z') || (c>='0' && c<='9') || c=='_' => return 1
	if others && others.strchr(c) => return 1
	return 0
}
int is_alpha(char c,char* others=NULL){
	if c>='a' && c<='z' || c>='A' && c<='Z' || c=='_' => return 1
	if others && others.strchr(c) => return 1
	return 0
}
int is_oper(char c) => return "~!@#$%^&*-=+|<>?/\\}]).".strchr(c) ? 1 : 0
int str_is_oper(char* str){
	if !str_len(str) => return 0
	while(*str++) if !"~!@#$%^&*-=+|:<>?/\\{[(}]),.".strchr(str[-1]) => return 0
	return 1
}
int str_is_num(char* str){
	if !str_len(str) => return 0
	while(*str++) if !is_number(str[-1]) => return 0
	return 1
}
int is_code(char* str){
	if !str_len(str) => return 0
	if !is_alpha(*str) => return 0
	while(*++str) if !is_alphanum(*str) => return 0
	return 1
}
int char_at(char* str,char* terms){
	if !str || !str.is_str() => return 0
	head=str
	while *str && !terms.strchr(*str) => str++
	return str-head
}
int rchar_at(char* str,char* terms){
	if !str || !str.is_str() => return 0
	tail=str+str.str_len()-1
	while tail>=str && !terms.strchr(*tail) => tail--
	return tail-str
}
char* char_str(char c){
	char ret[2]={0}
	ret[0]=c
	ret[1]='\0'
	str=ret.str_dup()
	assert(str.str_len()<=1)
	return str
}
int has_chars(char* line){
	if !line => return 0
	for ;*line;line++ => if !"\n\r \t".strchr(*line) => return 1
	return 0;	
}
